{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar observers_1 = require(\"./internal/observers\");\nvar util_1 = require(\"./internal/util\");\nvar constants_1 = require(\"./internal/constants\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\nvar bookmarks_1 = require(\"./internal/bookmarks\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar transaction_promise_1 = __importDefault(require(\"./transaction-promise\"));\nvar transaction_managed_1 = __importDefault(require(\"./transaction-managed\"));\nvar auth_util_1 = require(\"./internal/auth-util\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmarks} args.bookmarks - The initial bookmarks for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n   * @param {BookmarkManager} args.bookmarkManager - The bookmark manager used for this session.\n   * @param {NotificationFilter} args.notificationFilter - The notification filter used for this session.\n   * @param {AuthToken} args.auth - the target auth for the to-be-acquired connection\n   * @param {Logger} args.log - the logger used for logs in this session.\n   * @param {(user:string, database:string) => void} args.homeDatabaseCallback - callback used to update the home database cache\n   */\n  function Session(_a) {\n    var mode = _a.mode,\n      connectionProvider = _a.connectionProvider,\n      bookmarks = _a.bookmarks,\n      database = _a.database,\n      config = _a.config,\n      reactive = _a.reactive,\n      fetchSize = _a.fetchSize,\n      impersonatedUser = _a.impersonatedUser,\n      bookmarkManager = _a.bookmarkManager,\n      notificationFilter = _a.notificationFilter,\n      auth = _a.auth,\n      log = _a.log,\n      homeDatabaseCallback = _a.homeDatabaseCallback;\n    var _b;\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._homeDatabaseCallback = homeDatabaseCallback;\n    this._auth = auth;\n    this._getConnectionAcquistionBookmarks = this._getConnectionAcquistionBookmarks.bind(this);\n    this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_READ,\n      auth: auth,\n      database: database,\n      bookmarks: bookmarks,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n      getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n      log: log\n    });\n    this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_WRITE,\n      auth: auth,\n      database: database,\n      bookmarks: bookmarks,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n      getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n      log: log\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._impersonatedUser = impersonatedUser;\n    this._lastBookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n    this._configuredBookmarks = this._lastBookmarks;\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._databaseNameResolved = this._database !== '';\n    var calculatedWatermaks = this._calculateWatermaks();\n    this._lowRecordWatermark = calculatedWatermaks.low;\n    this._highRecordWatermark = calculatedWatermaks.high;\n    this._results = [];\n    this._bookmarkManager = bookmarkManager;\n    this._notificationFilter = notificationFilter;\n    this._log = log;\n    this._databaseGuess = config === null || config === void 0 ? void 0 : config.cachedHomeDatabase;\n    this._isRoutingSession = (_b = config === null || config === void 0 ? void 0 : config.routingDriver) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n  Session.prototype.run = function (query, parameters, transactionConfig) {\n    var _this = this;\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n      validatedQuery = _a.validatedQuery,\n      params = _a.params;\n    var autoCommitTxConfig = transactionConfig != null ? new tx_config_1.TxConfig(transactionConfig, this._log) : tx_config_1.TxConfig.empty();\n    var result = this._run(validatedQuery, params, function (connection) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var bookmarks;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, this._bookmarks()];\n            case 1:\n              bookmarks = _a.sent();\n              this._assertSessionIsOpen();\n              return [2 /*return*/, connection.run(validatedQuery, params, {\n                bookmarks: bookmarks,\n                txConfig: autoCommitTxConfig,\n                mode: this._mode,\n                database: this._database,\n                apiTelemetryConfig: {\n                  api: constants_1.TELEMETRY_APIS.AUTO_COMMIT_TRANSACTION\n                },\n                impersonatedUser: this._impersonatedUser,\n                afterComplete: function (meta) {\n                  return _this._onCompleteCallback(meta, bookmarks);\n                },\n                reactive: this._reactive,\n                fetchSize: this._fetchSize,\n                lowRecordWatermark: this._lowRecordWatermark,\n                highRecordWatermark: this._highRecordWatermark,\n                notificationFilter: this._notificationFilter,\n                onDb: this._onDatabaseNameResolved.bind(this)\n              })];\n          }\n        });\n      });\n    });\n    this._results.push(result);\n    return result;\n  };\n  Session.prototype._run = function (query, parameters, customRunner) {\n    var _a = this._acquireAndConsumeConnection(customRunner),\n      connectionHolder = _a.connectionHolder,\n      resultPromise = _a.resultPromise;\n    var observerPromise = resultPromise.catch(function (error) {\n      return Promise.resolve(new observers_1.FailedObserver({\n        error: error\n      }));\n    });\n    var watermarks = {\n      high: this._highRecordWatermark,\n      low: this._lowRecordWatermark\n    };\n    return new result_1.default(observerPromise, query, parameters, connectionHolder, watermarks);\n  };\n  /**\n   * This method is used by Rediscovery on the neo4j-driver-bolt-protocol package.\n   *\n   * @private\n   * @param {function()} connectionConsumer The method which will use the connection\n   * @returns {Promise<T>} A connection promise\n   */\n  Session.prototype._acquireConnection = function (connectionConsumer) {\n    var _this = this;\n    var _a = this._acquireAndConsumeConnection(connectionConsumer),\n      connectionHolder = _a.connectionHolder,\n      resultPromise = _a.resultPromise;\n    return resultPromise.then(function (result) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, connectionHolder.releaseConnection()];\n            case 1:\n              _a.sent();\n              return [2 /*return*/, result];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Acquires a {@link Connection}, consume it and return a promise of the result along with\n   * the {@link ConnectionHolder} used in the process.\n   *\n   * @private\n   * @param connectionConsumer\n   * @returns {object} The connection holder and connection promise.\n   */\n  Session.prototype._acquireAndConsumeConnection = function (connectionConsumer) {\n    var resultPromise;\n    var connectionHolder = this._connectionHolderWithMode(this._mode);\n    if (!this._open) {\n      resultPromise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n    } else if (!this._hasTx && connectionHolder.initializeConnection(this._databaseGuess)) {\n      resultPromise = connectionHolder.getConnection()\n      // Connection won't be null at this point since the initialize method\n      // return\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      .then(function (connection) {\n        return connectionConsumer(connection);\n      });\n    } else {\n      resultPromise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n    }\n    return {\n      connectionHolder: connectionHolder,\n      resultPromise: resultPromise\n    };\n  };\n  /**\n   * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n   * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n   *\n   * While a transaction is open the session cannot be used to run queries outside the transaction.\n   *\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @returns {TransactionPromise} New Transaction.\n   */\n  Session.prototype.beginTransaction = function (transactionConfig) {\n    // this function needs to support bookmarks parameter for backwards compatibility\n    // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n    // that's why we need to check parameter type and decide how to interpret the value\n    var arg = transactionConfig;\n    var txConfig = tx_config_1.TxConfig.empty();\n    if (arg != null) {\n      txConfig = new tx_config_1.TxConfig(arg, this._log);\n    }\n    return this._beginTransaction(this._mode, txConfig, {\n      api: constants_1.TELEMETRY_APIS.UNMANAGED_TRANSACTION\n    });\n  };\n  Session.prototype._beginTransaction = function (accessMode, txConfig, apiTelemetryConfig) {\n    var _this = this;\n    if (!this._open) {\n      throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n    }\n    if (this._hasTx) {\n      throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n    }\n    var mode = Session._validateSessionMode(accessMode);\n    var connectionHolder = this._connectionHolderWithMode(mode);\n    connectionHolder.initializeConnection(this._databaseGuess);\n    this._hasTx = true;\n    var tx = new transaction_promise_1.default({\n      connectionHolder: connectionHolder,\n      impersonatedUser: this._impersonatedUser,\n      onClose: this._transactionClosed.bind(this),\n      onBookmarks: function (newBm, oldBm, db) {\n        return _this._updateBookmarks(newBm, oldBm, db);\n      },\n      onConnection: this._assertSessionIsOpen.bind(this),\n      reactive: this._reactive,\n      fetchSize: this._fetchSize,\n      lowRecordWatermark: this._lowRecordWatermark,\n      highRecordWatermark: this._highRecordWatermark,\n      notificationFilter: this._notificationFilter,\n      apiTelemetryConfig: apiTelemetryConfig,\n      onDbCallback: this._onDatabaseNameResolved.bind(this)\n    });\n    tx._begin(function () {\n      return _this._bookmarks();\n    }, txConfig);\n    return tx;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._assertSessionIsOpen = function () {\n    if (!this._open) {\n      throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n    }\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._transactionClosed = function () {\n    this._hasTx = false;\n  };\n  /**\n   * Return the bookmarks received following the last completed {@link Transaction}.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use {@link Session#lastBookmarks} instead.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   * @see {@link Session#lastBookmarks}\n   */\n  Session.prototype.lastBookmark = function () {\n    return this.lastBookmarks();\n  };\n  /**\n   * Return the bookmarks received following the last completed {@link Transaction}.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   */\n  Session.prototype.lastBookmarks = function () {\n    return this._lastBookmarks.values();\n  };\n  Session.prototype._bookmarks = function () {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var bookmarks;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks()];\n          case 1:\n            bookmarks = _b.sent();\n            if (bookmarks === undefined) {\n              return [2 /*return*/, this._lastBookmarks];\n            }\n            return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(bookmarks), false), __read(this._configuredBookmarks), false))];\n        }\n      });\n    });\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeRead} instead.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   * @see {@link Session#executeRead}\n   */\n  Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeWrite} instead.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   * @see {@link Session#executeWrite}\n   */\n  Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n  Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n    return this._transactionExecutor.execute(function (apiTelemetryConfig) {\n      return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig);\n    }, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n   * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n   * {@link Session#run} for these).\n   *\n   * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n  Session.prototype.executeRead = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._executeInTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n   * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n   * {@link Session#run} for these).\n   *\n   * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n  Session.prototype.executeWrite = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n    return this._executeInTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n  /**\n   * @private\n   * @param {SessionMode} accessMode\n   * @param {TxConfig} transactionConfig\n   * @param {ManagedTransactionWork} transactionWork\n   * @returns {Promise}\n   */\n  Session.prototype._executeInTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n    return this._transactionExecutor.execute(function (apiTelemetryConfig) {\n      return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig);\n    }, transactionWork, transaction_managed_1.default.fromTransaction);\n  };\n  /**\n   * Sets the resolved database name in the session context.\n   * @private\n   * @param {string|undefined} database The resolved database name\n   * @returns {void}\n   */\n  Session.prototype._onDatabaseNameResolved = function (database) {\n    if (this._isRoutingSession) {\n      this._databaseGuess = database;\n      if (!this._databaseNameResolved) {\n        var normalizedDatabase = database !== null && database !== void 0 ? database : '';\n        this._database = normalizedDatabase;\n        this._readConnectionHolder.setDatabase(normalizedDatabase);\n        this._writeConnectionHolder.setDatabase(normalizedDatabase);\n        this._databaseNameResolved = true;\n        if (this._homeDatabaseCallback != null) {\n          this._homeDatabaseCallback((0, auth_util_1.cacheKey)(this._auth, this._impersonatedUser), database);\n        }\n      }\n    }\n  };\n  Session.prototype._getConnectionAcquistionBookmarks = function () {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var bookmarks;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks()];\n          case 1:\n            bookmarks = _b.sent();\n            if (bookmarks === undefined) {\n              return [2 /*return*/, this._lastBookmarks];\n            }\n            return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(this._configuredBookmarks), false), __read(bookmarks), false))];\n        }\n      });\n    });\n  };\n  /**\n   * Update value of the last bookmarks.\n   * @private\n   * @param {Bookmarks} newBookmarks - The new bookmarks.\n   * @returns {void}\n   */\n  Session.prototype._updateBookmarks = function (newBookmarks, previousBookmarks, database) {\n    var _a, _b, _c;\n    if (newBookmarks != null && !newBookmarks.isEmpty()) {\n      (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.updateBookmarks((_b = previousBookmarks === null || previousBookmarks === void 0 ? void 0 : previousBookmarks.values()) !== null && _b !== void 0 ? _b : [], (_c = newBookmarks === null || newBookmarks === void 0 ? void 0 : newBookmarks.values()) !== null && _c !== void 0 ? _c : []).catch(function () {});\n      this._lastBookmarks = newBookmarks;\n      this._configuredBookmarks = bookmarks_1.Bookmarks.empty();\n    }\n  };\n  /**\n   * Close this session.\n   * @return {Promise}\n   */\n  Session.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._open) return [3 /*break*/, 3];\n            this._open = false;\n            this._results.forEach(function (result) {\n              return result._cancel();\n            });\n            this._transactionExecutor.close();\n            return [4 /*yield*/, this._readConnectionHolder.close(this._hasTx)];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this._writeConnectionHolder.close(this._hasTx)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  // eslint-disable-next-line\n  // @ts-ignore\n  Session.prototype[Symbol.asyncDispose] = function () {\n    return this.close();\n  };\n  Session.prototype._connectionHolderWithMode = function (mode) {\n    if (mode === constants_1.ACCESS_MODE_READ) {\n      return this._readConnectionHolder;\n    } else if (mode === constants_1.ACCESS_MODE_WRITE) {\n      return this._writeConnectionHolder;\n    } else {\n      throw (0, error_1.newError)('Unknown access mode: ' + mode);\n    }\n  };\n  /**\n   * @private\n   * @param {Object} meta Connection metadatada\n   * @returns {void}\n   */\n  Session.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n    this._updateBookmarks(new bookmarks_1.Bookmarks(meta.bookmark), previousBookmarks, meta.db);\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._calculateWatermaks = function () {\n    if (this._fetchSize === constants_1.FETCH_ALL) {\n      return {\n        low: Number.MAX_VALUE,\n        high: Number.MAX_VALUE // we shall never reach this number to disable auto pull\n      };\n    }\n    return {\n      low: 0.3 * this._fetchSize,\n      high: 0.7 * this._fetchSize\n    };\n  };\n  /**\n   * Configure the transaction executor\n   *\n   * This used by {@link Driver#executeQuery}\n   * @private\n   * @returns {void}\n   */\n  Session.prototype._configureTransactionExecutor = function (pipelined, telemetryApi) {\n    this._transactionExecutor.pipelineBegin = pipelined;\n    this._transactionExecutor.telemetryApi = telemetryApi;\n  };\n  /**\n   * @protected\n   */\n  Session._validateSessionMode = function (rawMode) {\n    var mode = rawMode !== null && rawMode !== void 0 ? rawMode : constants_1.ACCESS_MODE_WRITE;\n    if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n      throw (0, error_1.newError)('Illegal session mode ' + mode);\n    }\n    return mode;\n  };\n  return Session;\n}();\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n  var _a;\n  var maxRetryTimeMs = (_a = config === null || config === void 0 ? void 0 : config.maxTransactionRetryTime) !== null && _a !== void 0 ? _a : null;\n  return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports.default = Session;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__read","o","m","i","r","ar","error","__spreadArray","to","from","pack","arguments","l","Array","prototype","slice","concat","__importDefault","mod","__esModule","Object","defineProperty","exports","observers_1","require","util_1","constants_1","error_1","result_1","connection_holder_1","transaction_executor_1","bookmarks_1","tx_config_1","transaction_promise_1","transaction_managed_1","auth_util_1","Session","_a","mode","connectionProvider","bookmarks","database","config","reactive","fetchSize","impersonatedUser","bookmarkManager","notificationFilter","auth","log","homeDatabaseCallback","_b","_mode","_database","_reactive","_fetchSize","_homeDatabaseCallback","_auth","_getConnectionAcquistionBookmarks","bind","_readConnectionHolder","ConnectionHolder","ACCESS_MODE_READ","onDatabaseNameResolved","_onDatabaseNameResolved","getConnectionAcquistionBookmarks","_writeConnectionHolder","ACCESS_MODE_WRITE","_open","_hasTx","_impersonatedUser","_lastBookmarks","Bookmarks","empty","_configuredBookmarks","_transactionExecutor","_createTransactionExecutor","_databaseNameResolved","calculatedWatermaks","_calculateWatermaks","_lowRecordWatermark","low","_highRecordWatermark","high","_results","_bookmarkManager","_notificationFilter","_log","_databaseGuess","cachedHomeDatabase","_isRoutingSession","routingDriver","run","query","parameters","transactionConfig","_this","validateQueryAndParameters","validatedQuery","params","autoCommitTxConfig","TxConfig","_run","connection","_bookmarks","_assertSessionIsOpen","txConfig","apiTelemetryConfig","api","TELEMETRY_APIS","AUTO_COMMIT_TRANSACTION","afterComplete","meta","_onCompleteCallback","lowRecordWatermark","highRecordWatermark","onDb","customRunner","_acquireAndConsumeConnection","connectionHolder","resultPromise","observerPromise","catch","FailedObserver","watermarks","default","_acquireConnection","connectionConsumer","releaseConnection","_connectionHolderWithMode","newError","initializeConnection","getConnection","beginTransaction","arg","_beginTransaction","UNMANAGED_TRANSACTION","accessMode","_validateSessionMode","tx","onClose","_transactionClosed","onBookmarks","newBm","oldBm","db","_updateBookmarks","onConnection","onDbCallback","_begin","lastBookmark","lastBookmarks","values","getBookmarks","undefined","readTransaction","transactionWork","_runTransaction","writeTransaction","execute","executeRead","_executeInTransaction","executeWrite","fromTransaction","normalizedDatabase","setDatabase","cacheKey","newBookmarks","previousBookmarks","_c","isEmpty","updateBookmarks","close","forEach","_cancel","asyncDispose","bookmark","FETCH_ALL","Number","MAX_VALUE","_configureTransactionExecutor","pipelined","telemetryApi","pipelineBegin","rawMode","maxRetryTimeMs","maxTransactionRetryTime","TransactionExecutor"],"sources":["D:/Study/Projects/El-Kasr Family Tree/client/node_modules/neo4j-driver-core/lib/session.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar observers_1 = require(\"./internal/observers\");\nvar util_1 = require(\"./internal/util\");\nvar constants_1 = require(\"./internal/constants\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\nvar bookmarks_1 = require(\"./internal/bookmarks\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar transaction_promise_1 = __importDefault(require(\"./transaction-promise\"));\nvar transaction_managed_1 = __importDefault(require(\"./transaction-managed\"));\nvar auth_util_1 = require(\"./internal/auth-util\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Object} args\n     * @param {string} args.mode the default access mode for this session.\n     * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n     * @param {Bookmarks} args.bookmarks - The initial bookmarks for this session.\n     * @param {string} args.database the database name\n     * @param {Object} args.config={} - This driver configuration.\n     * @param {boolean} args.reactive - Whether this session should create reactive streams\n     * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n     * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n     * @param {BookmarkManager} args.bookmarkManager - The bookmark manager used for this session.\n     * @param {NotificationFilter} args.notificationFilter - The notification filter used for this session.\n     * @param {AuthToken} args.auth - the target auth for the to-be-acquired connection\n     * @param {Logger} args.log - the logger used for logs in this session.\n     * @param {(user:string, database:string) => void} args.homeDatabaseCallback - callback used to update the home database cache\n     */\n    function Session(_a) {\n        var mode = _a.mode, connectionProvider = _a.connectionProvider, bookmarks = _a.bookmarks, database = _a.database, config = _a.config, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser, bookmarkManager = _a.bookmarkManager, notificationFilter = _a.notificationFilter, auth = _a.auth, log = _a.log, homeDatabaseCallback = _a.homeDatabaseCallback;\n        var _b;\n        this._mode = mode;\n        this._database = database;\n        this._reactive = reactive;\n        this._fetchSize = fetchSize;\n        this._homeDatabaseCallback = homeDatabaseCallback;\n        this._auth = auth;\n        this._getConnectionAcquistionBookmarks = this._getConnectionAcquistionBookmarks.bind(this);\n        this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_READ,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_WRITE,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._open = true;\n        this._hasTx = false;\n        this._impersonatedUser = impersonatedUser;\n        this._lastBookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n        this._configuredBookmarks = this._lastBookmarks;\n        this._transactionExecutor = _createTransactionExecutor(config);\n        this._databaseNameResolved = this._database !== '';\n        var calculatedWatermaks = this._calculateWatermaks();\n        this._lowRecordWatermark = calculatedWatermaks.low;\n        this._highRecordWatermark = calculatedWatermaks.high;\n        this._results = [];\n        this._bookmarkManager = bookmarkManager;\n        this._notificationFilter = notificationFilter;\n        this._log = log;\n        this._databaseGuess = config === null || config === void 0 ? void 0 : config.cachedHomeDatabase;\n        this._isRoutingSession = (_b = config === null || config === void 0 ? void 0 : config.routingDriver) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     *\n     * @public\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @return {Result} New Result.\n     */\n    Session.prototype.run = function (query, parameters, transactionConfig) {\n        var _this = this;\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var autoCommitTxConfig = (transactionConfig != null)\n            ? new tx_config_1.TxConfig(transactionConfig, this._log)\n            : tx_config_1.TxConfig.empty();\n        var result = this._run(validatedQuery, params, function (connection) { return __awaiter(_this, void 0, void 0, function () {\n            var bookmarks;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._bookmarks()];\n                    case 1:\n                        bookmarks = _a.sent();\n                        this._assertSessionIsOpen();\n                        return [2 /*return*/, connection.run(validatedQuery, params, {\n                                bookmarks: bookmarks,\n                                txConfig: autoCommitTxConfig,\n                                mode: this._mode,\n                                database: this._database,\n                                apiTelemetryConfig: {\n                                    api: constants_1.TELEMETRY_APIS.AUTO_COMMIT_TRANSACTION\n                                },\n                                impersonatedUser: this._impersonatedUser,\n                                afterComplete: function (meta) { return _this._onCompleteCallback(meta, bookmarks); },\n                                reactive: this._reactive,\n                                fetchSize: this._fetchSize,\n                                lowRecordWatermark: this._lowRecordWatermark,\n                                highRecordWatermark: this._highRecordWatermark,\n                                notificationFilter: this._notificationFilter,\n                                onDb: this._onDatabaseNameResolved.bind(this)\n                            })];\n                }\n            });\n        }); });\n        this._results.push(result);\n        return result;\n    };\n    Session.prototype._run = function (query, parameters, customRunner) {\n        var _a = this._acquireAndConsumeConnection(customRunner), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        var observerPromise = resultPromise.catch(function (error) { return Promise.resolve(new observers_1.FailedObserver({ error: error })); });\n        var watermarks = { high: this._highRecordWatermark, low: this._lowRecordWatermark };\n        return new result_1.default(observerPromise, query, parameters, connectionHolder, watermarks);\n    };\n    /**\n     * This method is used by Rediscovery on the neo4j-driver-bolt-protocol package.\n     *\n     * @private\n     * @param {function()} connectionConsumer The method which will use the connection\n     * @returns {Promise<T>} A connection promise\n     */\n    Session.prototype._acquireConnection = function (connectionConsumer) {\n        var _this = this;\n        var _a = this._acquireAndConsumeConnection(connectionConsumer), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        return resultPromise.then(function (result) { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, connectionHolder.releaseConnection()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        }); });\n    };\n    /**\n     * Acquires a {@link Connection}, consume it and return a promise of the result along with\n     * the {@link ConnectionHolder} used in the process.\n     *\n     * @private\n     * @param connectionConsumer\n     * @returns {object} The connection holder and connection promise.\n     */\n    Session.prototype._acquireAndConsumeConnection = function (connectionConsumer) {\n        var resultPromise;\n        var connectionHolder = this._connectionHolderWithMode(this._mode);\n        if (!this._open) {\n            resultPromise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        }\n        else if (!this._hasTx && connectionHolder.initializeConnection(this._databaseGuess)) {\n            resultPromise = connectionHolder\n                .getConnection()\n                // Connection won't be null at this point since the initialize method\n                // return\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                .then(function (connection) { return connectionConsumer(connection); });\n        }\n        else {\n            resultPromise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' +\n                'session with an open transaction; either run from within the ' +\n                'transaction or use a different session.'));\n        }\n        return { connectionHolder: connectionHolder, resultPromise: resultPromise };\n    };\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {TransactionPromise} New Transaction.\n     */\n    Session.prototype.beginTransaction = function (transactionConfig) {\n        // this function needs to support bookmarks parameter for backwards compatibility\n        // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n        // that's why we need to check parameter type and decide how to interpret the value\n        var arg = transactionConfig;\n        var txConfig = tx_config_1.TxConfig.empty();\n        if (arg != null) {\n            txConfig = new tx_config_1.TxConfig(arg, this._log);\n        }\n        return this._beginTransaction(this._mode, txConfig, { api: constants_1.TELEMETRY_APIS.UNMANAGED_TRANSACTION });\n    };\n    Session.prototype._beginTransaction = function (accessMode, txConfig, apiTelemetryConfig) {\n        var _this = this;\n        if (!this._open) {\n            throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n        }\n        if (this._hasTx) {\n            throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' +\n                'either run from within the transaction or use a different session.');\n        }\n        var mode = Session._validateSessionMode(accessMode);\n        var connectionHolder = this._connectionHolderWithMode(mode);\n        connectionHolder.initializeConnection(this._databaseGuess);\n        this._hasTx = true;\n        var tx = new transaction_promise_1.default({\n            connectionHolder: connectionHolder,\n            impersonatedUser: this._impersonatedUser,\n            onClose: this._transactionClosed.bind(this),\n            onBookmarks: function (newBm, oldBm, db) { return _this._updateBookmarks(newBm, oldBm, db); },\n            onConnection: this._assertSessionIsOpen.bind(this),\n            reactive: this._reactive,\n            fetchSize: this._fetchSize,\n            lowRecordWatermark: this._lowRecordWatermark,\n            highRecordWatermark: this._highRecordWatermark,\n            notificationFilter: this._notificationFilter,\n            apiTelemetryConfig: apiTelemetryConfig,\n            onDbCallback: this._onDatabaseNameResolved.bind(this)\n        });\n        tx._begin(function () { return _this._bookmarks(); }, txConfig);\n        return tx;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._assertSessionIsOpen = function () {\n        if (!this._open) {\n            throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._transactionClosed = function () {\n        this._hasTx = false;\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#lastBookmarks} instead.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     * @see {@link Session#lastBookmarks}\n     */\n    Session.prototype.lastBookmark = function () {\n        return this.lastBookmarks();\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n    Session.prototype.lastBookmarks = function () {\n        return this._lastBookmarks.values();\n    };\n    Session.prototype._bookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(bookmarks), false), __read(this._configuredBookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeRead} instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeRead}\n     */\n    Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeWrite} instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeWrite}\n     */\n    Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeRead = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeWrite = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    /**\n     * @private\n     * @param {SessionMode} accessMode\n     * @param {TxConfig} transactionConfig\n     * @param {ManagedTransactionWork} transactionWork\n     * @returns {Promise}\n     */\n    Session.prototype._executeInTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork, transaction_managed_1.default.fromTransaction);\n    };\n    /**\n     * Sets the resolved database name in the session context.\n     * @private\n     * @param {string|undefined} database The resolved database name\n     * @returns {void}\n     */\n    Session.prototype._onDatabaseNameResolved = function (database) {\n        if (this._isRoutingSession) {\n            this._databaseGuess = database;\n            if (!this._databaseNameResolved) {\n                var normalizedDatabase = database !== null && database !== void 0 ? database : '';\n                this._database = normalizedDatabase;\n                this._readConnectionHolder.setDatabase(normalizedDatabase);\n                this._writeConnectionHolder.setDatabase(normalizedDatabase);\n                this._databaseNameResolved = true;\n                if (this._homeDatabaseCallback != null) {\n                    this._homeDatabaseCallback((0, auth_util_1.cacheKey)(this._auth, this._impersonatedUser), database);\n                }\n            }\n        }\n    };\n    Session.prototype._getConnectionAcquistionBookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(this._configuredBookmarks), false), __read(bookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Update value of the last bookmarks.\n     * @private\n     * @param {Bookmarks} newBookmarks - The new bookmarks.\n     * @returns {void}\n     */\n    Session.prototype._updateBookmarks = function (newBookmarks, previousBookmarks, database) {\n        var _a, _b, _c;\n        if ((newBookmarks != null) && !newBookmarks.isEmpty()) {\n            (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.updateBookmarks((_b = previousBookmarks === null || previousBookmarks === void 0 ? void 0 : previousBookmarks.values()) !== null && _b !== void 0 ? _b : [], (_c = newBookmarks === null || newBookmarks === void 0 ? void 0 : newBookmarks.values()) !== null && _c !== void 0 ? _c : []).catch(function () { });\n            this._lastBookmarks = newBookmarks;\n            this._configuredBookmarks = bookmarks_1.Bookmarks.empty();\n        }\n    };\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n    Session.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._open) return [3 /*break*/, 3];\n                        this._open = false;\n                        this._results.forEach(function (result) { return result._cancel(); });\n                        this._transactionExecutor.close();\n                        return [4 /*yield*/, this._readConnectionHolder.close(this._hasTx)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this._writeConnectionHolder.close(this._hasTx)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Session.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    Session.prototype._connectionHolderWithMode = function (mode) {\n        if (mode === constants_1.ACCESS_MODE_READ) {\n            return this._readConnectionHolder;\n        }\n        else if (mode === constants_1.ACCESS_MODE_WRITE) {\n            return this._writeConnectionHolder;\n        }\n        else {\n            throw (0, error_1.newError)('Unknown access mode: ' + mode);\n        }\n    };\n    /**\n     * @private\n     * @param {Object} meta Connection metadatada\n     * @returns {void}\n     */\n    Session.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n        this._updateBookmarks(new bookmarks_1.Bookmarks(meta.bookmark), previousBookmarks, meta.db);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._calculateWatermaks = function () {\n        if (this._fetchSize === constants_1.FETCH_ALL) {\n            return {\n                low: Number.MAX_VALUE,\n                high: Number.MAX_VALUE // we shall never reach this number to disable auto pull\n            };\n        }\n        return {\n            low: 0.3 * this._fetchSize,\n            high: 0.7 * this._fetchSize\n        };\n    };\n    /**\n     * Configure the transaction executor\n     *\n     * This used by {@link Driver#executeQuery}\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._configureTransactionExecutor = function (pipelined, telemetryApi) {\n        this._transactionExecutor.pipelineBegin = pipelined;\n        this._transactionExecutor.telemetryApi = telemetryApi;\n    };\n    /**\n     * @protected\n     */\n    Session._validateSessionMode = function (rawMode) {\n        var mode = rawMode !== null && rawMode !== void 0 ? rawMode : constants_1.ACCESS_MODE_WRITE;\n        if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n            throw (0, error_1.newError)('Illegal session mode ' + mode);\n        }\n        return mode;\n    };\n    return Session;\n}());\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n    var _a;\n    var maxRetryTimeMs = (_a = config === null || config === void 0 ? void 0 : config.maxTransactionRetryTime) !== null && _a !== void 0 ? _a : null;\n    return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports.default = Session;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}