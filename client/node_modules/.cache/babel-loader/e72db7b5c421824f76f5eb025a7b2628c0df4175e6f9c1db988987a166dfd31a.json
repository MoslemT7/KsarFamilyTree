{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryConfig = exports.SessionConfig = exports.routing = exports.WRITE = exports.READ = exports.Driver = void 0;\nvar bookmarks_1 = require(\"./internal/bookmarks\");\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\nvar constants_1 = require(\"./internal/constants\");\nvar logger_1 = require(\"./internal/logger\");\nvar session_1 = __importDefault(require(\"./session\"));\nvar util_1 = require(\"./internal/util\");\nvar bookmark_manager_1 = require(\"./bookmark-manager\");\nvar result_transformers_1 = __importDefault(require(\"./result-transformers\"));\nvar query_executor_1 = __importDefault(require(\"./internal/query-executor\"));\nvar error_1 = require(\"./error\");\nvar homedb_cache_1 = __importDefault(require(\"./internal/homedb-cache\"));\nvar auth_util_1 = require(\"./internal/auth-util\");\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n/**\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\n * @type {number}\n */\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\n * The maximum number of entries allowed in the home database cache before pruning.\n */\nvar HOMEDB_CACHE_MAX_SIZE = 10000;\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\n * @type {string}\n */\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\n * @type {string}\n */\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * The session configuration\n *\n * @interface\n */\nvar SessionConfig = /** @class */function () {\n  /**\n   * @constructor\n   * @private\n   */\n  function SessionConfig() {\n    /**\n     * The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n     * **Default**: {@link WRITE}\n     * @type {string}\n     */\n    this.defaultAccessMode = WRITE;\n    /**\n     * The initial reference or references to some previous\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n     * @type {string|string[]|undefined}\n     */\n    this.bookmarks = [];\n    /**\n     * The database this session will operate on.\n     *\n     * This option has no explicit value by default, but it is recommended to set\n     * one if the target database is known in advance. This has the benefit of\n     * ensuring a consistent target database name throughout the session in a\n     * straightforward way and potentially simplifies driver logic as well as\n     * reduces network communication resulting in better performance.\n     *\n     * Usage of Cypher clauses like USE is not a replacement for this option.\n     * The driver does not parse any Cypher.\n     *\n     * When no explicit name is set, the driver behavior depends on the connection\n     * URI scheme supplied to the driver on instantiation and Bolt protocol\n     * version.\n     *\n     * Specifically, the following applies:\n     *\n     * - **bolt schemes** - queries are dispatched to the server for execution\n     *   without explicit database name supplied, meaning that the target database\n     *   name for query execution is determined by the server. It is important to\n     *   note that the target database may change (even within the same session),\n     *   for instance if the user's home database is changed on the server.\n     *\n     * - **neo4j schemes** - providing that Bolt protocol version 4.4, which was\n     *   introduced with Neo4j server 4.4, or above is available, the driver\n     *   fetches the user's home database name from the server on first query\n     *   execution within the session and uses the fetched database name\n     *   explicitly for all queries executed within the session. This ensures that\n     *   the database name remains consistent within the given session. For\n     *   instance, if the user's home database name is 'movies' and the server\n     *   supplies it to the driver upon database name fetching for the session,\n     *   all queries within that session are executed with the explicit database\n     *   name 'movies' supplied. Any change to the userâ€™s home database is\n     *   reflected only in sessions created after such change takes effect. This\n     *   behavior requires additional network communication. In clustered\n     *   environments, it is strongly recommended to avoid a single point of\n     *   failure. For instance, by ensuring that the connection URI resolves to\n     *   multiple endpoints. For older Bolt protocol versions the behavior is the\n     *   same as described for the **bolt schemes** above.\n     *\n     * @type {string|undefined}\n     */\n    this.database = '';\n    /**\n     * The username which the user wants to impersonate for the duration of the session.\n     *\n     * @type {string|undefined}\n     */\n    this.impersonatedUser = undefined;\n    /**\n     * The {@link AuthToken} which will be used for the duration of the session.\n     *\n     * By default, the session will use connections authenticated with the {@link AuthToken} configured on\n     * driver creation. This configuration allows switching user and/or authorization information for the\n     * session lifetime.\n     *\n     * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n     * which supports Bolt 5.1 or newer.\n     *\n     * @type {AuthToken|undefined}\n     * @see {@link driver}\n     */\n    this.auth = undefined;\n    /**\n     * The record fetch size of each batch of this session.\n     *\n     * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\n     *\n     * @type {number|undefined}\n     */\n    this.fetchSize = undefined;\n    /**\n     * Configure a BookmarkManager for the session to use\n     *\n     * A BookmarkManager is a piece of software responsible for keeping casual consistency between different sessions by sharing bookmarks\n     * between the them.\n     * Enabling it is done by supplying an BookmarkManager implementation instance to this param.\n     * A default implementation could be acquired by calling the factory function {@link bookmarkManager}.\n     *\n     * **Warning**: Sharing the same BookmarkManager instance across multiple sessions can have a negative impact\n     * on performance since all the queries will wait for the latest changes being propagated across the cluster.\n     * For keeping consistency between a group of queries, use {@link Session} for grouping them.\n     * For keeping consistency between a group of sessions, use {@link BookmarkManager} instance for grouping them.\n     *\n     * @example\n     * const bookmarkManager = neo4j.bookmarkManager()\n     * const linkedSession1 = driver.session({ database:'neo4j', bookmarkManager })\n     * const linkedSession2 = driver.session({ database:'neo4j', bookmarkManager })\n     * const unlinkedSession = driver.session({ database:'neo4j' })\n     *\n     * // Creating Driver User\n     * const createUserQueryResult = await linkedSession1.run('CREATE (p:Person {name: $name})', { name: 'Driver User'})\n     *\n     * // Reading Driver User will *NOT* wait of the changes being propagated to the server before RUN the query\n     * // So the 'Driver User' person might not exist in the Result\n     * const unlinkedReadResult = await unlinkedSession.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n     *\n     * // Reading Driver User will wait of the changes being propagated to the server before RUN the query\n     * // So the 'Driver User' person should exist in the Result, unless deleted.\n     * const linkedResult = await linkedSession2.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n     *\n     * await linkedSession1.close()\n     * await linkedSession2.close()\n     * await unlinkedSession.close()\n     *\n     * @type {BookmarkManager|undefined}\n     * @since 5.0\n     */\n    this.bookmarkManager = undefined;\n    /**\n     * Configure filter for {@link Notification} objects returned in {@link ResultSummary#notifications}.\n     *\n     * This configuration enables filter notifications by:\n     *\n     * * the minimum severity level ({@link NotificationFilterMinimumSeverityLevel})\n     * * disabling notification categories ({@link NotificationFilterDisabledCategory})\n     *\n     *\n     * Disabling notifications can be done by defining the minimum severity level to 'OFF'.\n     * At driver level, when omitted, uses the server's default.\n     * At session level, when omitted, defaults to what filters have been configured at driver level.\n     *\n     * Disabling categories or severities allows the server to skip analysis for those, which can speed up query\n     * execution.\n     *\n     * @example\n     * // enabling warning notification, but disabling `HINT` and `DEPRECATION` notifications.\n     * const session = driver.session({\n     *     database: 'neo4j',\n     *     notificationFilter: {\n     *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING, // or 'WARNING\n     *         disabledCategories: [\n     *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n     *             neo4j.notificationFilterDisabledCategory.DEPRECATION // or 'DEPRECATION'\n     *        ]\n     *     }\n     * })\n     *\n     * @example\n     * // disabling notifications for a session\n     * const session = driver.session({\n     *     database: 'neo4j',\n     *     notificationFilter: {\n     *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.OFF // or 'OFF'\n     *     }\n     * })\n     *\n     * @example\n     * // using default values configured in the driver\n     * const sessionWithDefaultValues = driver.session({ database: 'neo4j' })\n     * // or driver.session({ database: 'neo4j', notificationFilter: undefined })\n     *\n     * // using default minimum severity level, but disabling 'HINT' and 'UNRECOGNIZED'\n     * // notification categories\n     * const sessionWithDefaultSeverityLevel = driver.session({\n     *     database: 'neo4j',\n     *     notificationFilter: {\n     *         disabledCategories: [\n     *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n     *             neo4j.notificationFilterDisabledCategory.UNRECOGNIZED // or 'UNRECOGNIZED'\n     *        ]\n     *     }\n     * })\n     *\n     * // using default disabled categories, but configuring minimum severity level to 'WARNING'\n     * const sessionWithDefaultSeverityLevel = driver.session({\n     *     database: 'neo4j',\n     *     notificationFilter: {\n     *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING // or 'WARNING'\n     *     }\n     * })\n     *\n     * @type {NotificationFilter|undefined}\n     * @since 5.7\n     */\n    this.notificationFilter = undefined;\n  }\n  return SessionConfig;\n}();\nexports.SessionConfig = SessionConfig;\nvar ROUTING_WRITE = 'WRITE';\nvar ROUTING_READ = 'READ';\n/**\n * @typedef {'WRITE'|'READ'} RoutingControl\n */\n/**\n * Constants that represents routing modes.\n *\n * @example\n * driver.executeQuery(\"<QUERY>\", <PARAMETERS>, { routing: neo4j.routing.WRITE })\n */\nvar routing = {\n  WRITE: ROUTING_WRITE,\n  READ: ROUTING_READ\n};\nexports.routing = routing;\nObject.freeze(routing);\n/**\n * The query configuration\n * @interface\n */\nvar QueryConfig = /** @class */function () {\n  /**\n   * @constructor\n   * @private\n   */\n  function QueryConfig() {\n    /**\n     * Define the type of cluster member the query will be routed to.\n     *\n     * @type {RoutingControl}\n     */\n    this.routing = routing.WRITE;\n    /**\n     * Define the transformation will be applied to the Result before return from the\n     * query method.\n     *\n     * @type {ResultTransformer}\n     * @see {@link resultTransformers} for provided implementations.\n     */\n    this.resultTransformer = undefined;\n    /**\n     * The database this session will operate on.\n     *\n     * @type {string|undefined}\n     */\n    this.database = '';\n    /**\n     * The username which the user wants to impersonate for the duration of the query.\n     *\n     * @type {string|undefined}\n     */\n    this.impersonatedUser = undefined;\n    /**\n     * Configure a BookmarkManager for the session to use\n     *\n     * A BookmarkManager is a piece of software responsible for keeping casual consistency between different pieces of work by sharing bookmarks\n     * between the them.\n     *\n     * By default, it uses the driver's non mutable driver level bookmark manager. See, {@link Driver.executeQueryBookmarkManager}\n     *\n     * Can be set to null to disable causal chaining.\n     * @type {BookmarkManager|undefined|null}\n     */\n    this.bookmarkManager = undefined;\n    /**\n     * Configuration for all transactions started to execute the query.\n     *\n     * @type {TransactionConfig|undefined}\n     *\n     */\n    this.transactionConfig = undefined;\n    /**\n     * The {@link AuthToken} which will be used for executing the query.\n     *\n     * By default, the query executor will use connections authenticated with the {@link AuthToken} configured on\n     * driver creation. This configuration allows switching user and/or authorization information for the\n     * underlying transaction's lifetime.\n     *\n     * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n     * which support Bolt 5.1 or newer.\n     *\n     * @type {AuthToken|undefined}\n     * @see {@link driver}\n     */\n    this.auth = undefined;\n    /**\n     * The {@link AbortSignal} for aborting query execution.\n     *\n     * When aborted, the signal triggers the result consumption cancelation and\n     * transactions are reset. However, due to race conditions,\n     * there is no guarantee the transaction will be rolled back.\n     * Equivalent to {@link Session.close}\n     *\n     * **Warning**: This option is only available in runtime which supports AbortSignal.addEventListener.\n     *\n     * @since 5.22.0\n     * @type {AbortSignal|undefined}\n     * @experimental\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n     */\n    this.signal = undefined;\n  }\n  return QueryConfig;\n}();\nexports.QueryConfig = QueryConfig;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send queries\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\nvar Driver = /** @class */function () {\n  /**\n   * You should not be calling this directly, instead use {@link driver}.\n   * @constructor\n   * @protected\n   * @param {Object} meta Metainformation about the driver\n   * @param {Object} config\n   * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectionProvider Creates the connection provider\n   * @param {function(args): Session } createSession Creates the a session\n  */\n  function Driver(meta, config, createConnectionProvider, createSession, createQueryExecutor) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (createSession === void 0) {\n      createSession = function (args) {\n        return new session_1.default(args);\n      };\n    }\n    if (createQueryExecutor === void 0) {\n      createQueryExecutor = function (createSession) {\n        return new query_executor_1.default(createSession);\n      };\n    }\n    sanitizeConfig(config);\n    var log = logger_1.Logger.create(config);\n    validateConfig(config, log);\n    this._id = idGenerator++;\n    this._meta = meta;\n    this._config = config;\n    this._log = log;\n    this._createConnectionProvider = createConnectionProvider;\n    this._createSession = createSession;\n    this._defaultExecuteQueryBookmarkManager = (0, bookmark_manager_1.bookmarkManager)();\n    this._queryExecutor = createQueryExecutor(this.session.bind(this));\n    /**\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n     * @type {ConnectionProvider}\n     * @protected\n     */\n    this._connectionProvider = null;\n    /**\n     * @private\n     */\n    this.homeDatabaseCache = new homedb_cache_1.default(HOMEDB_CACHE_MAX_SIZE);\n    this._afterConstruction();\n  }\n  Object.defineProperty(Driver.prototype, \"executeQueryBookmarkManager\", {\n    /**\n     * The bookmark managed used by {@link Driver.executeQuery}\n     *\n     * @type {BookmarkManager}\n     */\n    get: function () {\n      return this._defaultExecuteQueryBookmarkManager;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Executes a query in a retriable context and returns a {@link EagerResult}.\n   *\n   * This method is a shortcut for a {@link Session#executeRead} and {@link Session#executeWrite}.\n   *\n   * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n   * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n   * {@link Session#run} for these).\n   *\n   * @example\n   * // Run a simple write query\n   * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'})\n   *\n   * @example\n   * // Run a read query\n   * const { keys, records, summary } = await driver.executeQuery(\n   *    'MATCH (p:Person{ name: $name }) RETURN p',\n   *    { name: 'Person1'},\n   *    { routing: neo4j.routing.READ})\n   *\n   * @example\n   * // Run a read query returning a Person Nodes per elementId\n   * const peopleMappedById = await driver.executeQuery(\n   *    'MATCH (p:Person{ name: $name }) RETURN p',\n   *    { name: 'Person1'},\n   *    {\n   *      resultTransformer: neo4j.resultTransformers.mappedResultTransformer({\n   *        map(record) {\n   *          const p = record.get('p')\n   *          return [p.elementId, p]\n   *        },\n   *        collect(elementIdPersonPairArray) {\n   *          return new Map(elementIdPersonPairArray)\n   *        }\n   *      })\n   *    }\n   * )\n   *\n   * const person = peopleMappedById.get(\"<ELEMENT_ID>\")\n   *\n   * @example\n   * // these lines\n   * const transformedResult = await driver.executeQuery(\n   *    \"<QUERY>\",\n   *    <PARAMETERS>,\n   *    {\n   *       routing: neo4j.routing.WRITE,\n   *       resultTransformer: transformer,\n   *       database: \"<DATABASE>\",\n   *       impersonatedUser: \"<USER>\",\n   *       bookmarkManager: bookmarkManager\n   *    })\n   * // are equivalent to those\n   * const session = driver.session({\n   *    database: \"<DATABASE>\",\n   *    impersonatedUser: \"<USER>\",\n   *    bookmarkManager: bookmarkManager\n   * })\n   *\n   * try {\n   *    const transformedResult = await session.executeWrite(tx => {\n   *        const result = tx.run(\"<QUERY>\", <PARAMETERS>)\n   *        return transformer(result)\n   *    })\n   * } finally {\n   *    await session.close()\n   * }\n   *\n   * @public\n   * @param {string | {text: string, parameters?: object}} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in the query\n   * @param {QueryConfig<T>} config - The query configuration\n   * @returns {Promise<T>}\n   *\n   * @see {@link resultTransformers} for provided result transformers.\n   */\n  Driver.prototype.executeQuery = function (query, parameters, config) {\n    var _a, _b, _c;\n    if (config === void 0) {\n      config = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var bookmarkManager, resultTransformer, routingConfig;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            bookmarkManager = config.bookmarkManager === null ? undefined : (_a = config.bookmarkManager) !== null && _a !== void 0 ? _a : this.executeQueryBookmarkManager;\n            resultTransformer = (_b = config.resultTransformer) !== null && _b !== void 0 ? _b : result_transformers_1.default.eagerResultTransformer();\n            routingConfig = (_c = config.routing) !== null && _c !== void 0 ? _c : routing.WRITE;\n            if (routingConfig !== routing.READ && routingConfig !== routing.WRITE) {\n              throw (0, error_1.newError)(\"Illegal query routing config: \\\"\".concat(routingConfig, \"\\\"\"));\n            }\n            return [4 /*yield*/, this._queryExecutor.execute({\n              resultTransformer: resultTransformer,\n              bookmarkManager: bookmarkManager,\n              routing: routingConfig,\n              database: config.database,\n              impersonatedUser: config.impersonatedUser,\n              transactionConfig: config.transactionConfig,\n              auth: config.auth,\n              signal: config.signal\n            }, query, parameters)];\n          case 1:\n            return [2 /*return*/, _d.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\n   *\n   * @deprecated This return of this method will change in 6.0.0 to not async return the {@link ServerInfo} and\n   * async return {@link void} instead. If you need to use the server info, use {@link getServerInfo} instead.\n   *\n   * @public\n   * @param {Object} param - The object parameter\n   * @param {string} param.database - The target database to verify connectivity for.\n   * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n   */\n  Driver.prototype.verifyConnectivity = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.database,\n      database = _c === void 0 ? '' : _c;\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.verifyConnectivityAndGetServerInfo({\n      database: database,\n      accessMode: READ\n    });\n  };\n  /**\n   * This method verifies the authorization credentials work by trying to acquire a connection\n   * to one of the servers with the given credentials.\n   *\n   * @param {object} param - object parameter\n   * @property {AuthToken} param.auth - the target auth for the to-be-acquired connection\n   * @property {string} param.database - the target database for the to-be-acquired connection\n   *\n   * @returns {Promise<boolean>} promise resolved with true if succeed, false if failed with\n   *  authentication issue and rejected with error if non-authentication error happens.\n   */\n  Driver.prototype.verifyAuthentication = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      database = _b.database,\n      auth = _b.auth;\n    return __awaiter(this, void 0, void 0, function () {\n      var connectionProvider;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            connectionProvider = this._getOrCreateConnectionProvider();\n            return [4 /*yield*/, connectionProvider.verifyAuthentication({\n              database: database !== null && database !== void 0 ? database : 'system',\n              auth: auth,\n              accessMode: READ\n            })];\n          case 1:\n            return [2 /*return*/, _c.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Get ServerInfo for the giver database.\n   *\n   * @param {Object} param - The object parameter\n   * @param {string} param.database - The target database to verify connectivity for.\n   * @returns {Promise<ServerInfo>} promise resolved with the ServerInfo or rejected with error.\n   */\n  Driver.prototype.getServerInfo = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.database,\n      database = _c === void 0 ? '' : _c;\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.verifyConnectivityAndGetServerInfo({\n      database: database,\n      accessMode: READ\n    });\n  };\n  /**\n   * Returns whether the server supports multi database capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsMultiDb = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsMultiDb();\n  };\n  /**\n   * Returns whether the server supports transaction config capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsTransactionConfig = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsTransactionConfig();\n  };\n  /**\n   * Returns whether the server supports user impersonation capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsUserImpersonation = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsUserImpersonation();\n  };\n  /**\n   * Returns whether the driver session re-auth functionality capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsSessionAuth = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsSessionAuth();\n  };\n  /**\n   * Returns the protocol version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<number>} the protocol version negotiated via handshake.\n   * @throws {Error} When protocol negotiation fails\n   */\n  Driver.prototype.getNegotiatedProtocolVersion = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.getNegotiatedProtocolVersion();\n  };\n  /**\n   * Returns boolean to indicate if driver has been configured with encryption enabled.\n   *\n   * @returns {boolean}\n   */\n  Driver.prototype.isEncrypted = function () {\n    return this._isEncrypted();\n  };\n  /**\n   * @protected\n   * @returns {boolean}\n   */\n  Driver.prototype._supportsRouting = function () {\n    return this._meta.routing;\n  };\n  /**\n   * Returns boolean to indicate if driver has been configured with encryption enabled.\n   *\n   * @protected\n   * @returns {boolean}\n   */\n  Driver.prototype._isEncrypted = function () {\n    return this._config.encrypted === util_1.ENCRYPTION_ON || this._config.encrypted === true;\n  };\n  /**\n   * Returns the configured trust strategy that the driver has been configured with.\n   *\n   * @protected\n   * @returns {TrustStrategy}\n   */\n  Driver.prototype._getTrust = function () {\n    return this._config.trust;\n  };\n  /**\n   * Acquire a session to communicate with the database. The session will\n   * borrow connections from the underlying connection pool as required and\n   * should be considered lightweight and disposable.\n   *\n   * This comes with some responsibility - make sure you always call\n   * {@link close} when you are done using a session, and likewise,\n   * make sure you don't close your session before you are done using it. Once\n   * it is closed, the underlying connection will be released to the connection\n   * pool and made available for others to use.\n   *\n   * @public\n   * @param {SessionConfig} param - The session configuration\n   * @return {Session} new session.\n   */\n  Driver.prototype.session = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.defaultAccessMode,\n      defaultAccessMode = _c === void 0 ? WRITE : _c,\n      bookmarkOrBookmarks = _b.bookmarks,\n      _d = _b.database,\n      database = _d === void 0 ? '' : _d,\n      impersonatedUser = _b.impersonatedUser,\n      fetchSize = _b.fetchSize,\n      bookmarkManager = _b.bookmarkManager,\n      notificationFilter = _b.notificationFilter,\n      auth = _b.auth;\n    return this._newSession({\n      defaultAccessMode: defaultAccessMode,\n      bookmarkOrBookmarks: bookmarkOrBookmarks,\n      database: database,\n      reactive: false,\n      impersonatedUser: impersonatedUser,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize),\n      bookmarkManager: bookmarkManager,\n      notificationFilter: notificationFilter,\n      auth: auth\n    });\n  };\n  /**\n   * Close all open sessions and other associated resources. You should\n   * make sure to use this when you are done with this driver instance.\n   * @public\n   * @return {Promise<void>} promise resolved when the driver is closed.\n   */\n  Driver.prototype.close = function () {\n    this._log.info(\"Driver \".concat(this._id, \" closing\"));\n    if (this._connectionProvider != null) {\n      return this._connectionProvider.close();\n    }\n    return Promise.resolve();\n  };\n  // eslint-disable-next-line\n  // @ts-ignore\n  Driver.prototype[Symbol.asyncDispose] = function () {\n    return this.close();\n  };\n  /**\n   * @protected\n   * @returns {void}\n   */\n  Driver.prototype._afterConstruction = function () {\n    this._log.info(\"\".concat(this._meta.typename, \" driver \").concat(this._id, \" created for server address \").concat(this._meta.address.toString()));\n  };\n  Driver.prototype._homeDatabaseCallback = function (cacheKey, database) {\n    this.homeDatabaseCache.set(cacheKey, database);\n  };\n  /**\n   * @private\n   */\n  Driver.prototype._newSession = function (_a) {\n    var defaultAccessMode = _a.defaultAccessMode,\n      bookmarkOrBookmarks = _a.bookmarkOrBookmarks,\n      database = _a.database,\n      reactive = _a.reactive,\n      impersonatedUser = _a.impersonatedUser,\n      fetchSize = _a.fetchSize,\n      bookmarkManager = _a.bookmarkManager,\n      notificationFilter = _a.notificationFilter,\n      auth = _a.auth;\n    var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    // eslint-disable-next-line\n    var cachedHomeDatabase = this.homeDatabaseCache.get((0, auth_util_1.cacheKey)(auth, impersonatedUser));\n    var homeDatabaseCallback = this._homeDatabaseCallback.bind(this);\n    var bookmarks = bookmarkOrBookmarks != null ? new bookmarks_1.Bookmarks(bookmarkOrBookmarks) : bookmarks_1.Bookmarks.empty();\n    return this._createSession({\n      mode: sessionMode,\n      database: database !== null && database !== void 0 ? database : '',\n      connectionProvider: connectionProvider,\n      bookmarks: bookmarks,\n      config: __assign({\n        cachedHomeDatabase: cachedHomeDatabase,\n        routingDriver: this._supportsRouting()\n      }, this._config),\n      reactive: reactive,\n      impersonatedUser: impersonatedUser,\n      fetchSize: fetchSize,\n      bookmarkManager: bookmarkManager,\n      notificationFilter: notificationFilter,\n      auth: auth,\n      log: this._log,\n      homeDatabaseCallback: homeDatabaseCallback\n    });\n  };\n  /**\n   * @private\n   */\n  Driver.prototype._getOrCreateConnectionProvider = function () {\n    if (this._connectionProvider == null) {\n      this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n    }\n    return this._connectionProvider;\n  };\n  return Driver;\n}();\nexports.Driver = Driver;\n/**\n * @private\n * @returns {Object} the given config.\n */\nfunction validateConfig(config, log) {\n  var _a, _b;\n  var resolver = config.resolver;\n  if (resolver !== null && resolver !== undefined && typeof resolver !== 'function') {\n    throw new TypeError(\"Configured resolver should be a function. Got: \".concat(typeof resolver));\n  }\n  if (config.connectionAcquisitionTimeout < config.connectionTimeout) {\n    log.warn('Configuration for \"connectionAcquisitionTimeout\" should be greater than ' + 'or equal to \"connectionTimeout\". Otherwise, the connection acquisition ' + 'timeout will take precedence for over the connection timeout in scenarios ' + 'where a new connection is created while it is acquired');\n  }\n  if (((_a = config.notificationFilter) === null || _a === void 0 ? void 0 : _a.disabledCategories) != null && ((_b = config.notificationFilter) === null || _b === void 0 ? void 0 : _b.disabledClassifications) != null) {\n    throw new Error('The notificationFilter can\\'t have both \"disabledCategories\" and  \"disabledClassifications\" configured at the same time.');\n  }\n  return config;\n}\n/**\n * @private\n * @returns {void}\n */\nfunction sanitizeConfig(config) {\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n  config.connectionTimeout = extractConnectionTimeout(config);\n  config.connectionLivenessCheckTimeout = validateConnectionLivenessCheckTimeoutSizeValue(config.connectionLivenessCheckTimeout);\n}\n/**\n * @private\n * @returns {number}\n */\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n  var sanitizedValue = parseInt(rawValue, 10);\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\n    return sanitizedValue;\n  } else if (sanitizedValue < 0) {\n    return Number.MAX_SAFE_INTEGER;\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\n * @private\n */\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n  var fetchSize = parseInt(rawValue, 10);\n  if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n    return fetchSize;\n  } else if (fetchSize === 0 || fetchSize < 0) {\n    throw new Error(\"The fetch size can only be a positive value or \".concat(constants_1.FETCH_ALL, \" for ALL. However fetchSize = \").concat(fetchSize));\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\n * @private\n */\nfunction extractConnectionTimeout(config) {\n  var configuredTimeout = parseInt(config.connectionTimeout, 10);\n  if (configuredTimeout === 0) {\n    // timeout explicitly configured to 0\n    return null;\n  } else if (!isNaN(configuredTimeout) && configuredTimeout < 0) {\n    // timeout explicitly configured to a negative value\n    return null;\n  } else if (isNaN(configuredTimeout)) {\n    // timeout not configured, use default value\n    return constants_1.DEFAULT_CONNECTION_TIMEOUT_MILLIS;\n  } else {\n    // timeout configured, use the provided value\n    return configuredTimeout;\n  }\n}\n/**\n * @private\n */\nfunction validateConnectionLivenessCheckTimeoutSizeValue(rawValue) {\n  if (rawValue == null) {\n    return undefined;\n  }\n  var connectionLivenessCheckTimeout = parseInt(rawValue, 10);\n  if (connectionLivenessCheckTimeout < 0 || Number.isNaN(connectionLivenessCheckTimeout)) {\n    throw new Error(\"The connectionLivenessCheckTimeout can only be a positive value or 0 for always. However connectionLivenessCheckTimeout = \".concat(connectionLivenessCheckTimeout));\n  }\n  return connectionLivenessCheckTimeout;\n}\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\nfunction createHostNameResolver(config) {\n  return new configured_custom_resolver_1.default(config.resolver);\n}\nexports.default = Driver;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","Symbol","iterator","v","op","TypeError","pop","push","__importDefault","mod","__esModule","defineProperty","exports","QueryConfig","SessionConfig","routing","WRITE","READ","Driver","bookmarks_1","require","configured_custom_resolver_1","constants_1","logger_1","session_1","util_1","bookmark_manager_1","result_transformers_1","query_executor_1","error_1","homedb_cache_1","auth_util_1","DEFAULT_MAX_CONNECTION_LIFETIME","DEFAULT_FETCH_SIZE","HOMEDB_CACHE_MAX_SIZE","ACCESS_MODE_READ","ACCESS_MODE_WRITE","idGenerator","defaultAccessMode","bookmarks","database","impersonatedUser","undefined","auth","fetchSize","bookmarkManager","notificationFilter","ROUTING_WRITE","ROUTING_READ","freeze","resultTransformer","transactionConfig","signal","meta","config","createConnectionProvider","createSession","createQueryExecutor","args","default","sanitizeConfig","log","Logger","create","validateConfig","_id","_meta","_config","_log","_createConnectionProvider","_createSession","_defaultExecuteQueryBookmarkManager","_queryExecutor","session","bind","_connectionProvider","homeDatabaseCache","_afterConstruction","get","enumerable","configurable","executeQuery","query","parameters","_a","_b","_c","routingConfig","_d","executeQueryBookmarkManager","eagerResultTransformer","newError","concat","execute","verifyConnectivity","connectionProvider","_getOrCreateConnectionProvider","verifyConnectivityAndGetServerInfo","accessMode","verifyAuthentication","getServerInfo","supportsMultiDb","supportsTransactionConfig","supportsUserImpersonation","supportsSessionAuth","getNegotiatedProtocolVersion","isEncrypted","_isEncrypted","_supportsRouting","encrypted","ENCRYPTION_ON","_getTrust","trust","bookmarkOrBookmarks","_newSession","reactive","validateFetchSizeValue","close","info","asyncDispose","typename","address","toString","_homeDatabaseCallback","cacheKey","set","sessionMode","_validateSessionMode","cachedHomeDatabase","homeDatabaseCallback","Bookmarks","empty","mode","routingDriver","createHostNameResolver","resolver","connectionAcquisitionTimeout","connectionTimeout","warn","disabledCategories","disabledClassifications","Error","maxConnectionLifetime","sanitizeIntValue","maxConnectionPoolSize","DEFAULT_POOL_MAX_SIZE","DEFAULT_POOL_ACQUISITION_TIMEOUT","extractConnectionTimeout","connectionLivenessCheckTimeout","validateConnectionLivenessCheckTimeoutSizeValue","rawValue","defaultWhenAbsent","sanitizedValue","parseInt","Number","MAX_SAFE_INTEGER","FETCH_ALL","configuredTimeout","isNaN","DEFAULT_CONNECTION_TIMEOUT_MILLIS"],"sources":["D:/Study/Projects/El-Kasr Family Tree/client/node_modules/neo4j-driver-core/lib/driver.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryConfig = exports.SessionConfig = exports.routing = exports.WRITE = exports.READ = exports.Driver = void 0;\nvar bookmarks_1 = require(\"./internal/bookmarks\");\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\nvar constants_1 = require(\"./internal/constants\");\nvar logger_1 = require(\"./internal/logger\");\nvar session_1 = __importDefault(require(\"./session\"));\nvar util_1 = require(\"./internal/util\");\nvar bookmark_manager_1 = require(\"./bookmark-manager\");\nvar result_transformers_1 = __importDefault(require(\"./result-transformers\"));\nvar query_executor_1 = __importDefault(require(\"./internal/query-executor\"));\nvar error_1 = require(\"./error\");\nvar homedb_cache_1 = __importDefault(require(\"./internal/homedb-cache\"));\nvar auth_util_1 = require(\"./internal/auth-util\");\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n/**\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\n * @type {number}\n */\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\n * The maximum number of entries allowed in the home database cache before pruning.\n */\nvar HOMEDB_CACHE_MAX_SIZE = 10000;\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\n * @type {string}\n */\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\n * @type {string}\n */\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * The session configuration\n *\n * @interface\n */\nvar SessionConfig = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function SessionConfig() {\n        /**\n         * The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n         * **Default**: {@link WRITE}\n         * @type {string}\n         */\n        this.defaultAccessMode = WRITE;\n        /**\n         * The initial reference or references to some previous\n         * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n         * @type {string|string[]|undefined}\n         */\n        this.bookmarks = [];\n        /**\n         * The database this session will operate on.\n         *\n         * This option has no explicit value by default, but it is recommended to set\n         * one if the target database is known in advance. This has the benefit of\n         * ensuring a consistent target database name throughout the session in a\n         * straightforward way and potentially simplifies driver logic as well as\n         * reduces network communication resulting in better performance.\n         *\n         * Usage of Cypher clauses like USE is not a replacement for this option.\n         * The driver does not parse any Cypher.\n         *\n         * When no explicit name is set, the driver behavior depends on the connection\n         * URI scheme supplied to the driver on instantiation and Bolt protocol\n         * version.\n         *\n         * Specifically, the following applies:\n         *\n         * - **bolt schemes** - queries are dispatched to the server for execution\n         *   without explicit database name supplied, meaning that the target database\n         *   name for query execution is determined by the server. It is important to\n         *   note that the target database may change (even within the same session),\n         *   for instance if the user's home database is changed on the server.\n         *\n         * - **neo4j schemes** - providing that Bolt protocol version 4.4, which was\n         *   introduced with Neo4j server 4.4, or above is available, the driver\n         *   fetches the user's home database name from the server on first query\n         *   execution within the session and uses the fetched database name\n         *   explicitly for all queries executed within the session. This ensures that\n         *   the database name remains consistent within the given session. For\n         *   instance, if the user's home database name is 'movies' and the server\n         *   supplies it to the driver upon database name fetching for the session,\n         *   all queries within that session are executed with the explicit database\n         *   name 'movies' supplied. Any change to the userâ€™s home database is\n         *   reflected only in sessions created after such change takes effect. This\n         *   behavior requires additional network communication. In clustered\n         *   environments, it is strongly recommended to avoid a single point of\n         *   failure. For instance, by ensuring that the connection URI resolves to\n         *   multiple endpoints. For older Bolt protocol versions the behavior is the\n         *   same as described for the **bolt schemes** above.\n         *\n         * @type {string|undefined}\n         */\n        this.database = '';\n        /**\n         * The username which the user wants to impersonate for the duration of the session.\n         *\n         * @type {string|undefined}\n         */\n        this.impersonatedUser = undefined;\n        /**\n         * The {@link AuthToken} which will be used for the duration of the session.\n         *\n         * By default, the session will use connections authenticated with the {@link AuthToken} configured on\n         * driver creation. This configuration allows switching user and/or authorization information for the\n         * session lifetime.\n         *\n         * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n         * which supports Bolt 5.1 or newer.\n         *\n         * @type {AuthToken|undefined}\n         * @see {@link driver}\n         */\n        this.auth = undefined;\n        /**\n         * The record fetch size of each batch of this session.\n         *\n         * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\n         *\n         * @type {number|undefined}\n         */\n        this.fetchSize = undefined;\n        /**\n         * Configure a BookmarkManager for the session to use\n         *\n         * A BookmarkManager is a piece of software responsible for keeping casual consistency between different sessions by sharing bookmarks\n         * between the them.\n         * Enabling it is done by supplying an BookmarkManager implementation instance to this param.\n         * A default implementation could be acquired by calling the factory function {@link bookmarkManager}.\n         *\n         * **Warning**: Sharing the same BookmarkManager instance across multiple sessions can have a negative impact\n         * on performance since all the queries will wait for the latest changes being propagated across the cluster.\n         * For keeping consistency between a group of queries, use {@link Session} for grouping them.\n         * For keeping consistency between a group of sessions, use {@link BookmarkManager} instance for grouping them.\n         *\n         * @example\n         * const bookmarkManager = neo4j.bookmarkManager()\n         * const linkedSession1 = driver.session({ database:'neo4j', bookmarkManager })\n         * const linkedSession2 = driver.session({ database:'neo4j', bookmarkManager })\n         * const unlinkedSession = driver.session({ database:'neo4j' })\n         *\n         * // Creating Driver User\n         * const createUserQueryResult = await linkedSession1.run('CREATE (p:Person {name: $name})', { name: 'Driver User'})\n         *\n         * // Reading Driver User will *NOT* wait of the changes being propagated to the server before RUN the query\n         * // So the 'Driver User' person might not exist in the Result\n         * const unlinkedReadResult = await unlinkedSession.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n         *\n         * // Reading Driver User will wait of the changes being propagated to the server before RUN the query\n         * // So the 'Driver User' person should exist in the Result, unless deleted.\n         * const linkedResult = await linkedSession2.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n         *\n         * await linkedSession1.close()\n         * await linkedSession2.close()\n         * await unlinkedSession.close()\n         *\n         * @type {BookmarkManager|undefined}\n         * @since 5.0\n         */\n        this.bookmarkManager = undefined;\n        /**\n         * Configure filter for {@link Notification} objects returned in {@link ResultSummary#notifications}.\n         *\n         * This configuration enables filter notifications by:\n         *\n         * * the minimum severity level ({@link NotificationFilterMinimumSeverityLevel})\n         * * disabling notification categories ({@link NotificationFilterDisabledCategory})\n         *\n         *\n         * Disabling notifications can be done by defining the minimum severity level to 'OFF'.\n         * At driver level, when omitted, uses the server's default.\n         * At session level, when omitted, defaults to what filters have been configured at driver level.\n         *\n         * Disabling categories or severities allows the server to skip analysis for those, which can speed up query\n         * execution.\n         *\n         * @example\n         * // enabling warning notification, but disabling `HINT` and `DEPRECATION` notifications.\n         * const session = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING, // or 'WARNING\n         *         disabledCategories: [\n         *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n         *             neo4j.notificationFilterDisabledCategory.DEPRECATION // or 'DEPRECATION'\n         *        ]\n         *     }\n         * })\n         *\n         * @example\n         * // disabling notifications for a session\n         * const session = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.OFF // or 'OFF'\n         *     }\n         * })\n         *\n         * @example\n         * // using default values configured in the driver\n         * const sessionWithDefaultValues = driver.session({ database: 'neo4j' })\n         * // or driver.session({ database: 'neo4j', notificationFilter: undefined })\n         *\n         * // using default minimum severity level, but disabling 'HINT' and 'UNRECOGNIZED'\n         * // notification categories\n         * const sessionWithDefaultSeverityLevel = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         disabledCategories: [\n         *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n         *             neo4j.notificationFilterDisabledCategory.UNRECOGNIZED // or 'UNRECOGNIZED'\n         *        ]\n         *     }\n         * })\n         *\n         * // using default disabled categories, but configuring minimum severity level to 'WARNING'\n         * const sessionWithDefaultSeverityLevel = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING // or 'WARNING'\n         *     }\n         * })\n         *\n         * @type {NotificationFilter|undefined}\n         * @since 5.7\n         */\n        this.notificationFilter = undefined;\n    }\n    return SessionConfig;\n}());\nexports.SessionConfig = SessionConfig;\nvar ROUTING_WRITE = 'WRITE';\nvar ROUTING_READ = 'READ';\n/**\n * @typedef {'WRITE'|'READ'} RoutingControl\n */\n/**\n * Constants that represents routing modes.\n *\n * @example\n * driver.executeQuery(\"<QUERY>\", <PARAMETERS>, { routing: neo4j.routing.WRITE })\n */\nvar routing = {\n    WRITE: ROUTING_WRITE,\n    READ: ROUTING_READ\n};\nexports.routing = routing;\nObject.freeze(routing);\n/**\n * The query configuration\n * @interface\n */\nvar QueryConfig = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function QueryConfig() {\n        /**\n         * Define the type of cluster member the query will be routed to.\n         *\n         * @type {RoutingControl}\n         */\n        this.routing = routing.WRITE;\n        /**\n         * Define the transformation will be applied to the Result before return from the\n         * query method.\n         *\n         * @type {ResultTransformer}\n         * @see {@link resultTransformers} for provided implementations.\n         */\n        this.resultTransformer = undefined;\n        /**\n         * The database this session will operate on.\n         *\n         * @type {string|undefined}\n         */\n        this.database = '';\n        /**\n         * The username which the user wants to impersonate for the duration of the query.\n         *\n         * @type {string|undefined}\n         */\n        this.impersonatedUser = undefined;\n        /**\n         * Configure a BookmarkManager for the session to use\n         *\n         * A BookmarkManager is a piece of software responsible for keeping casual consistency between different pieces of work by sharing bookmarks\n         * between the them.\n         *\n         * By default, it uses the driver's non mutable driver level bookmark manager. See, {@link Driver.executeQueryBookmarkManager}\n         *\n         * Can be set to null to disable causal chaining.\n         * @type {BookmarkManager|undefined|null}\n         */\n        this.bookmarkManager = undefined;\n        /**\n         * Configuration for all transactions started to execute the query.\n         *\n         * @type {TransactionConfig|undefined}\n         *\n         */\n        this.transactionConfig = undefined;\n        /**\n         * The {@link AuthToken} which will be used for executing the query.\n         *\n         * By default, the query executor will use connections authenticated with the {@link AuthToken} configured on\n         * driver creation. This configuration allows switching user and/or authorization information for the\n         * underlying transaction's lifetime.\n         *\n         * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n         * which support Bolt 5.1 or newer.\n         *\n         * @type {AuthToken|undefined}\n         * @see {@link driver}\n         */\n        this.auth = undefined;\n        /**\n         * The {@link AbortSignal} for aborting query execution.\n         *\n         * When aborted, the signal triggers the result consumption cancelation and\n         * transactions are reset. However, due to race conditions,\n         * there is no guarantee the transaction will be rolled back.\n         * Equivalent to {@link Session.close}\n         *\n         * **Warning**: This option is only available in runtime which supports AbortSignal.addEventListener.\n         *\n         * @since 5.22.0\n         * @type {AbortSignal|undefined}\n         * @experimental\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n         */\n        this.signal = undefined;\n    }\n    return QueryConfig;\n}());\nexports.QueryConfig = QueryConfig;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send queries\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\nvar Driver = /** @class */ (function () {\n    /**\n     * You should not be calling this directly, instead use {@link driver}.\n     * @constructor\n     * @protected\n     * @param {Object} meta Metainformation about the driver\n     * @param {Object} config\n     * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectionProvider Creates the connection provider\n     * @param {function(args): Session } createSession Creates the a session\n    */\n    function Driver(meta, config, createConnectionProvider, createSession, createQueryExecutor) {\n        if (config === void 0) { config = {}; }\n        if (createSession === void 0) { createSession = function (args) { return new session_1.default(args); }; }\n        if (createQueryExecutor === void 0) { createQueryExecutor = function (createSession) { return new query_executor_1.default(createSession); }; }\n        sanitizeConfig(config);\n        var log = logger_1.Logger.create(config);\n        validateConfig(config, log);\n        this._id = idGenerator++;\n        this._meta = meta;\n        this._config = config;\n        this._log = log;\n        this._createConnectionProvider = createConnectionProvider;\n        this._createSession = createSession;\n        this._defaultExecuteQueryBookmarkManager = (0, bookmark_manager_1.bookmarkManager)();\n        this._queryExecutor = createQueryExecutor(this.session.bind(this));\n        /**\n         * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n         * @type {ConnectionProvider}\n         * @protected\n         */\n        this._connectionProvider = null;\n        /**\n         * @private\n         */\n        this.homeDatabaseCache = new homedb_cache_1.default(HOMEDB_CACHE_MAX_SIZE);\n        this._afterConstruction();\n    }\n    Object.defineProperty(Driver.prototype, \"executeQueryBookmarkManager\", {\n        /**\n         * The bookmark managed used by {@link Driver.executeQuery}\n         *\n         * @type {BookmarkManager}\n         */\n        get: function () {\n            return this._defaultExecuteQueryBookmarkManager;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Executes a query in a retriable context and returns a {@link EagerResult}.\n     *\n     * This method is a shortcut for a {@link Session#executeRead} and {@link Session#executeWrite}.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @example\n     * // Run a simple write query\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'})\n     *\n     * @example\n     * // Run a read query\n     * const { keys, records, summary } = await driver.executeQuery(\n     *    'MATCH (p:Person{ name: $name }) RETURN p',\n     *    { name: 'Person1'},\n     *    { routing: neo4j.routing.READ})\n     *\n     * @example\n     * // Run a read query returning a Person Nodes per elementId\n     * const peopleMappedById = await driver.executeQuery(\n     *    'MATCH (p:Person{ name: $name }) RETURN p',\n     *    { name: 'Person1'},\n     *    {\n     *      resultTransformer: neo4j.resultTransformers.mappedResultTransformer({\n     *        map(record) {\n     *          const p = record.get('p')\n     *          return [p.elementId, p]\n     *        },\n     *        collect(elementIdPersonPairArray) {\n     *          return new Map(elementIdPersonPairArray)\n     *        }\n     *      })\n     *    }\n     * )\n     *\n     * const person = peopleMappedById.get(\"<ELEMENT_ID>\")\n     *\n     * @example\n     * // these lines\n     * const transformedResult = await driver.executeQuery(\n     *    \"<QUERY>\",\n     *    <PARAMETERS>,\n     *    {\n     *       routing: neo4j.routing.WRITE,\n     *       resultTransformer: transformer,\n     *       database: \"<DATABASE>\",\n     *       impersonatedUser: \"<USER>\",\n     *       bookmarkManager: bookmarkManager\n     *    })\n     * // are equivalent to those\n     * const session = driver.session({\n     *    database: \"<DATABASE>\",\n     *    impersonatedUser: \"<USER>\",\n     *    bookmarkManager: bookmarkManager\n     * })\n     *\n     * try {\n     *    const transformedResult = await session.executeWrite(tx => {\n     *        const result = tx.run(\"<QUERY>\", <PARAMETERS>)\n     *        return transformer(result)\n     *    })\n     * } finally {\n     *    await session.close()\n     * }\n     *\n     * @public\n     * @param {string | {text: string, parameters?: object}} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in the query\n     * @param {QueryConfig<T>} config - The query configuration\n     * @returns {Promise<T>}\n     *\n     * @see {@link resultTransformers} for provided result transformers.\n     */\n    Driver.prototype.executeQuery = function (query, parameters, config) {\n        var _a, _b, _c;\n        if (config === void 0) { config = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarkManager, resultTransformer, routingConfig;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        bookmarkManager = config.bookmarkManager === null ? undefined : ((_a = config.bookmarkManager) !== null && _a !== void 0 ? _a : this.executeQueryBookmarkManager);\n                        resultTransformer = ((_b = config.resultTransformer) !== null && _b !== void 0 ? _b : result_transformers_1.default.eagerResultTransformer());\n                        routingConfig = (_c = config.routing) !== null && _c !== void 0 ? _c : routing.WRITE;\n                        if (routingConfig !== routing.READ && routingConfig !== routing.WRITE) {\n                            throw (0, error_1.newError)(\"Illegal query routing config: \\\"\".concat(routingConfig, \"\\\"\"));\n                        }\n                        return [4 /*yield*/, this._queryExecutor.execute({\n                                resultTransformer: resultTransformer,\n                                bookmarkManager: bookmarkManager,\n                                routing: routingConfig,\n                                database: config.database,\n                                impersonatedUser: config.impersonatedUser,\n                                transactionConfig: config.transactionConfig,\n                                auth: config.auth,\n                                signal: config.signal\n                            }, query, parameters)];\n                    case 1: return [2 /*return*/, _d.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\n     *\n     * @deprecated This return of this method will change in 6.0.0 to not async return the {@link ServerInfo} and\n     * async return {@link void} instead. If you need to use the server info, use {@link getServerInfo} instead.\n     *\n     * @public\n     * @param {Object} param - The object parameter\n     * @param {string} param.database - The target database to verify connectivity for.\n     * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n     */\n    Driver.prototype.verifyConnectivity = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.verifyConnectivityAndGetServerInfo({ database: database, accessMode: READ });\n    };\n    /**\n     * This method verifies the authorization credentials work by trying to acquire a connection\n     * to one of the servers with the given credentials.\n     *\n     * @param {object} param - object parameter\n     * @property {AuthToken} param.auth - the target auth for the to-be-acquired connection\n     * @property {string} param.database - the target database for the to-be-acquired connection\n     *\n     * @returns {Promise<boolean>} promise resolved with true if succeed, false if failed with\n     *  authentication issue and rejected with error if non-authentication error happens.\n     */\n    Driver.prototype.verifyAuthentication = function (_a) {\n        var _b = _a === void 0 ? {} : _a, database = _b.database, auth = _b.auth;\n        return __awaiter(this, void 0, void 0, function () {\n            var connectionProvider;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        connectionProvider = this._getOrCreateConnectionProvider();\n                        return [4 /*yield*/, connectionProvider.verifyAuthentication({\n                                database: database !== null && database !== void 0 ? database : 'system',\n                                auth: auth,\n                                accessMode: READ\n                            })];\n                    case 1: return [2 /*return*/, _c.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Get ServerInfo for the giver database.\n     *\n     * @param {Object} param - The object parameter\n     * @param {string} param.database - The target database to verify connectivity for.\n     * @returns {Promise<ServerInfo>} promise resolved with the ServerInfo or rejected with error.\n     */\n    Driver.prototype.getServerInfo = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.verifyConnectivityAndGetServerInfo({ database: database, accessMode: READ });\n    };\n    /**\n     * Returns whether the server supports multi database capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsMultiDb = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsMultiDb();\n    };\n    /**\n     * Returns whether the server supports transaction config capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsTransactionConfig = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsTransactionConfig();\n    };\n    /**\n     * Returns whether the server supports user impersonation capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsUserImpersonation = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsUserImpersonation();\n    };\n    /**\n     * Returns whether the driver session re-auth functionality capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsSessionAuth = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsSessionAuth();\n    };\n    /**\n     * Returns the protocol version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<number>} the protocol version negotiated via handshake.\n     * @throws {Error} When protocol negotiation fails\n     */\n    Driver.prototype.getNegotiatedProtocolVersion = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.getNegotiatedProtocolVersion();\n    };\n    /**\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\n     *\n     * @returns {boolean}\n     */\n    Driver.prototype.isEncrypted = function () {\n        return this._isEncrypted();\n    };\n    /**\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._supportsRouting = function () {\n        return this._meta.routing;\n    };\n    /**\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._isEncrypted = function () {\n        return this._config.encrypted === util_1.ENCRYPTION_ON || this._config.encrypted === true;\n    };\n    /**\n     * Returns the configured trust strategy that the driver has been configured with.\n     *\n     * @protected\n     * @returns {TrustStrategy}\n     */\n    Driver.prototype._getTrust = function () {\n        return this._config.trust;\n    };\n    /**\n     * Acquire a session to communicate with the database. The session will\n     * borrow connections from the underlying connection pool as required and\n     * should be considered lightweight and disposable.\n     *\n     * This comes with some responsibility - make sure you always call\n     * {@link close} when you are done using a session, and likewise,\n     * make sure you don't close your session before you are done using it. Once\n     * it is closed, the underlying connection will be released to the connection\n     * pool and made available for others to use.\n     *\n     * @public\n     * @param {SessionConfig} param - The session configuration\n     * @return {Session} new session.\n     */\n    Driver.prototype.session = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultAccessMode, defaultAccessMode = _c === void 0 ? WRITE : _c, bookmarkOrBookmarks = _b.bookmarks, _d = _b.database, database = _d === void 0 ? '' : _d, impersonatedUser = _b.impersonatedUser, fetchSize = _b.fetchSize, bookmarkManager = _b.bookmarkManager, notificationFilter = _b.notificationFilter, auth = _b.auth;\n        return this._newSession({\n            defaultAccessMode: defaultAccessMode,\n            bookmarkOrBookmarks: bookmarkOrBookmarks,\n            database: database,\n            reactive: false,\n            impersonatedUser: impersonatedUser,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize),\n            bookmarkManager: bookmarkManager,\n            notificationFilter: notificationFilter,\n            auth: auth\n        });\n    };\n    /**\n     * Close all open sessions and other associated resources. You should\n     * make sure to use this when you are done with this driver instance.\n     * @public\n     * @return {Promise<void>} promise resolved when the driver is closed.\n     */\n    Driver.prototype.close = function () {\n        this._log.info(\"Driver \".concat(this._id, \" closing\"));\n        if (this._connectionProvider != null) {\n            return this._connectionProvider.close();\n        }\n        return Promise.resolve();\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Driver.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    /**\n     * @protected\n     * @returns {void}\n     */\n    Driver.prototype._afterConstruction = function () {\n        this._log.info(\"\".concat(this._meta.typename, \" driver \").concat(this._id, \" created for server address \").concat(this._meta.address.toString()));\n    };\n    Driver.prototype._homeDatabaseCallback = function (cacheKey, database) {\n        this.homeDatabaseCache.set(cacheKey, database);\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._newSession = function (_a) {\n        var defaultAccessMode = _a.defaultAccessMode, bookmarkOrBookmarks = _a.bookmarkOrBookmarks, database = _a.database, reactive = _a.reactive, impersonatedUser = _a.impersonatedUser, fetchSize = _a.fetchSize, bookmarkManager = _a.bookmarkManager, notificationFilter = _a.notificationFilter, auth = _a.auth;\n        var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        // eslint-disable-next-line\n        var cachedHomeDatabase = this.homeDatabaseCache.get((0, auth_util_1.cacheKey)(auth, impersonatedUser));\n        var homeDatabaseCallback = this._homeDatabaseCallback.bind(this);\n        var bookmarks = bookmarkOrBookmarks != null\n            ? new bookmarks_1.Bookmarks(bookmarkOrBookmarks)\n            : bookmarks_1.Bookmarks.empty();\n        return this._createSession({\n            mode: sessionMode,\n            database: database !== null && database !== void 0 ? database : '',\n            connectionProvider: connectionProvider,\n            bookmarks: bookmarks,\n            config: __assign({ cachedHomeDatabase: cachedHomeDatabase, routingDriver: this._supportsRouting() }, this._config),\n            reactive: reactive,\n            impersonatedUser: impersonatedUser,\n            fetchSize: fetchSize,\n            bookmarkManager: bookmarkManager,\n            notificationFilter: notificationFilter,\n            auth: auth,\n            log: this._log,\n            homeDatabaseCallback: homeDatabaseCallback\n        });\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._getOrCreateConnectionProvider = function () {\n        if (this._connectionProvider == null) {\n            this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n        }\n        return this._connectionProvider;\n    };\n    return Driver;\n}());\nexports.Driver = Driver;\n/**\n * @private\n * @returns {Object} the given config.\n */\nfunction validateConfig(config, log) {\n    var _a, _b;\n    var resolver = config.resolver;\n    if (resolver !== null && resolver !== undefined && typeof resolver !== 'function') {\n        throw new TypeError(\"Configured resolver should be a function. Got: \".concat(typeof resolver));\n    }\n    if (config.connectionAcquisitionTimeout < config.connectionTimeout) {\n        log.warn('Configuration for \"connectionAcquisitionTimeout\" should be greater than ' +\n            'or equal to \"connectionTimeout\". Otherwise, the connection acquisition ' +\n            'timeout will take precedence for over the connection timeout in scenarios ' +\n            'where a new connection is created while it is acquired');\n    }\n    if (((_a = config.notificationFilter) === null || _a === void 0 ? void 0 : _a.disabledCategories) != null && ((_b = config.notificationFilter) === null || _b === void 0 ? void 0 : _b.disabledClassifications) != null) {\n        throw new Error('The notificationFilter can\\'t have both \"disabledCategories\" and  \"disabledClassifications\" configured at the same time.');\n    }\n    return config;\n}\n/**\n * @private\n * @returns {void}\n */\nfunction sanitizeConfig(config) {\n    config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n    config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n    config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n    config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n    config.connectionTimeout = extractConnectionTimeout(config);\n    config.connectionLivenessCheckTimeout =\n        validateConnectionLivenessCheckTimeoutSizeValue(config.connectionLivenessCheckTimeout);\n}\n/**\n * @private\n * @returns {number}\n */\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n    var sanitizedValue = parseInt(rawValue, 10);\n    if (sanitizedValue > 0 || sanitizedValue === 0) {\n        return sanitizedValue;\n    }\n    else if (sanitizedValue < 0) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n */\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n    var fetchSize = parseInt(rawValue, 10);\n    if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n        return fetchSize;\n    }\n    else if (fetchSize === 0 || fetchSize < 0) {\n        throw new Error(\"The fetch size can only be a positive value or \".concat(constants_1.FETCH_ALL, \" for ALL. However fetchSize = \").concat(fetchSize));\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n */\nfunction extractConnectionTimeout(config) {\n    var configuredTimeout = parseInt(config.connectionTimeout, 10);\n    if (configuredTimeout === 0) {\n        // timeout explicitly configured to 0\n        return null;\n    }\n    else if (!isNaN(configuredTimeout) && configuredTimeout < 0) {\n        // timeout explicitly configured to a negative value\n        return null;\n    }\n    else if (isNaN(configuredTimeout)) {\n        // timeout not configured, use default value\n        return constants_1.DEFAULT_CONNECTION_TIMEOUT_MILLIS;\n    }\n    else {\n        // timeout configured, use the provided value\n        return configuredTimeout;\n    }\n}\n/**\n * @private\n */\nfunction validateConnectionLivenessCheckTimeoutSizeValue(rawValue) {\n    if (rawValue == null) {\n        return undefined;\n    }\n    var connectionLivenessCheckTimeout = parseInt(rawValue, 10);\n    if (connectionLivenessCheckTimeout < 0 || Number.isNaN(connectionLivenessCheckTimeout)) {\n        throw new Error(\"The connectionLivenessCheckTimeout can only be a positive value or 0 for always. However connectionLivenessCheckTimeout = \".concat(connectionLivenessCheckTimeout));\n    }\n    return connectionLivenessCheckTimeout;\n}\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\nfunction createHostNameResolver(config) {\n    return new configured_custom_resolver_1.default(config.resolver);\n}\nexports.default = Driver;\n"],"mappings":"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B;AACA;AACA;AACA,IAAIC,qBAAqB,GAAG,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA,IAAIjB,IAAI,GAAGK,WAAW,CAACa,gBAAgB;AACvCvB,OAAO,CAACK,IAAI,GAAGA,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA,IAAID,KAAK,GAAGM,WAAW,CAACc,iBAAiB;AACzCxB,OAAO,CAACI,KAAK,GAAGA,KAAK;AACrB,IAAIqB,WAAW,GAAG,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA,IAAIvB,aAAa,GAAG,aAAe,YAAY;EAC3C;AACJ;AACA;AACA;EACI,SAASA,aAAaA,CAAA,EAAG;IACrB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACwB,iBAAiB,GAAGtB,KAAK;IAC9B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACuB,SAAS,GAAG,EAAE;IACnB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAGC,SAAS;IACjC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,IAAI,GAAGD,SAAS;IACrB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,SAAS,GAAGF,SAAS;IAC1B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,eAAe,GAAGH,SAAS;IAChC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACI,kBAAkB,GAAGJ,SAAS;EACvC;EACA,OAAO5B,aAAa;AACxB,CAAC,CAAC,CAAE;AACJF,OAAO,CAACE,aAAa,GAAGA,aAAa;AACrC,IAAIiC,aAAa,GAAG,OAAO;AAC3B,IAAIC,YAAY,GAAG,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIjC,OAAO,GAAG;EACVC,KAAK,EAAE+B,aAAa;EACpB9B,IAAI,EAAE+B;AACV,CAAC;AACDpC,OAAO,CAACG,OAAO,GAAGA,OAAO;AACzBxD,MAAM,CAAC0F,MAAM,CAAClC,OAAO,CAAC;AACtB;AACA;AACA;AACA;AACA,IAAIF,WAAW,GAAG,aAAe,YAAY;EACzC;AACJ;AACA;AACA;EACI,SAASA,WAAWA,CAAA,EAAG;IACnB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACE,OAAO,GAAGA,OAAO,CAACC,KAAK;IAC5B;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACkC,iBAAiB,GAAGR,SAAS;IAClC;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACF,QAAQ,GAAG,EAAE;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAGC,SAAS;IACjC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,eAAe,GAAGH,SAAS;IAChC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACS,iBAAiB,GAAGT,SAAS;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,IAAI,GAAGD,SAAS;IACrB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACU,MAAM,GAAGV,SAAS;EAC3B;EACA,OAAO7B,WAAW;AACtB,CAAC,CAAC,CAAE;AACJD,OAAO,CAACC,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIK,MAAM,GAAG,aAAe,YAAY;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASA,MAAMA,CAACmC,IAAI,EAAEC,MAAM,EAAEC,wBAAwB,EAAEC,aAAa,EAAEC,mBAAmB,EAAE;IACxF,IAAIH,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,CAAC,CAAC;IAAE;IACtC,IAAIE,aAAa,KAAK,KAAK,CAAC,EAAE;MAAEA,aAAa,GAAG,SAAAA,CAAUE,IAAI,EAAE;QAAE,OAAO,IAAIlC,SAAS,CAACmC,OAAO,CAACD,IAAI,CAAC;MAAE,CAAC;IAAE;IACzG,IAAID,mBAAmB,KAAK,KAAK,CAAC,EAAE;MAAEA,mBAAmB,GAAG,SAAAA,CAAUD,aAAa,EAAE;QAAE,OAAO,IAAI5B,gBAAgB,CAAC+B,OAAO,CAACH,aAAa,CAAC;MAAE,CAAC;IAAE;IAC9II,cAAc,CAACN,MAAM,CAAC;IACtB,IAAIO,GAAG,GAAGtC,QAAQ,CAACuC,MAAM,CAACC,MAAM,CAACT,MAAM,CAAC;IACxCU,cAAc,CAACV,MAAM,EAAEO,GAAG,CAAC;IAC3B,IAAI,CAACI,GAAG,GAAG5B,WAAW,EAAE;IACxB,IAAI,CAAC6B,KAAK,GAAGb,IAAI;IACjB,IAAI,CAACc,OAAO,GAAGb,MAAM;IACrB,IAAI,CAACc,IAAI,GAAGP,GAAG;IACf,IAAI,CAACQ,yBAAyB,GAAGd,wBAAwB;IACzD,IAAI,CAACe,cAAc,GAAGd,aAAa;IACnC,IAAI,CAACe,mCAAmC,GAAG,CAAC,CAAC,EAAE7C,kBAAkB,CAACmB,eAAe,EAAE,CAAC;IACpF,IAAI,CAAC2B,cAAc,GAAGf,mBAAmB,CAAC,IAAI,CAACgB,OAAO,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClE;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,mBAAmB,GAAG,IAAI;IAC/B;AACR;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAI9C,cAAc,CAAC6B,OAAO,CAACzB,qBAAqB,CAAC;IAC1E,IAAI,CAAC2C,kBAAkB,CAAC,CAAC;EAC7B;EACAtH,MAAM,CAACoD,cAAc,CAACO,MAAM,CAAClD,SAAS,EAAE,6BAA6B,EAAE;IACnE;AACR;AACA;AACA;AACA;IACQ8G,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACP,mCAAmC;IACnD,CAAC;IACDQ,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI9D,MAAM,CAAClD,SAAS,CAACiH,YAAY,GAAG,UAAUC,KAAK,EAAEC,UAAU,EAAE7B,MAAM,EAAE;IACjE,IAAI8B,EAAE,EAAEC,EAAE,EAAEC,EAAE;IACd,IAAIhC,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,CAAC,CAAC;IAAE;IACtC,OAAOlF,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;MAC/C,IAAIyE,eAAe,EAAEK,iBAAiB,EAAEqC,aAAa;MACrD,OAAOjG,WAAW,CAAC,IAAI,EAAE,UAAUkG,EAAE,EAAE;QACnC,QAAQA,EAAE,CAAC/F,KAAK;UACZ,KAAK,CAAC;YACFoD,eAAe,GAAGS,MAAM,CAACT,eAAe,KAAK,IAAI,GAAGH,SAAS,GAAI,CAAC0C,EAAE,GAAG9B,MAAM,CAACT,eAAe,MAAM,IAAI,IAAIuC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI,CAACK,2BAA4B;YACjKvC,iBAAiB,GAAI,CAACmC,EAAE,GAAG/B,MAAM,CAACJ,iBAAiB,MAAM,IAAI,IAAImC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG1D,qBAAqB,CAACgC,OAAO,CAAC+B,sBAAsB,CAAC,CAAE;YAC7IH,aAAa,GAAG,CAACD,EAAE,GAAGhC,MAAM,CAACvC,OAAO,MAAM,IAAI,IAAIuE,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGvE,OAAO,CAACC,KAAK;YACpF,IAAIuE,aAAa,KAAKxE,OAAO,CAACE,IAAI,IAAIsE,aAAa,KAAKxE,OAAO,CAACC,KAAK,EAAE;cACnE,MAAM,CAAC,CAAC,EAAEa,OAAO,CAAC8D,QAAQ,EAAE,kCAAkC,CAACC,MAAM,CAACL,aAAa,EAAE,IAAI,CAAC,CAAC;YAC/F;YACA,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACf,cAAc,CAACqB,OAAO,CAAC;cACzC3C,iBAAiB,EAAEA,iBAAiB;cACpCL,eAAe,EAAEA,eAAe;cAChC9B,OAAO,EAAEwE,aAAa;cACtB/C,QAAQ,EAAEc,MAAM,CAACd,QAAQ;cACzBC,gBAAgB,EAAEa,MAAM,CAACb,gBAAgB;cACzCU,iBAAiB,EAAEG,MAAM,CAACH,iBAAiB;cAC3CR,IAAI,EAAEW,MAAM,CAACX,IAAI;cACjBS,MAAM,EAAEE,MAAM,CAACF;YACnB,CAAC,EAAE8B,KAAK,EAAEC,UAAU,CAAC,CAAC;UAC9B,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,YAAYK,EAAE,CAAC9F,IAAI,CAAC,CAAC,CAAC;QAC5C;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIwB,MAAM,CAAClD,SAAS,CAAC8H,kBAAkB,GAAG,UAAUV,EAAE,EAAE;IAChD,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAEE,EAAE,GAAGD,EAAE,CAAC7C,QAAQ;MAAEA,QAAQ,GAAG8C,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IACtF,IAAIS,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACE,kCAAkC,CAAC;MAAEzD,QAAQ,EAAEA,QAAQ;MAAE0D,UAAU,EAAEjF;IAAK,CAAC,CAAC;EAC1G,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAM,CAAClD,SAAS,CAACmI,oBAAoB,GAAG,UAAUf,EAAE,EAAE;IAClD,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAE5C,QAAQ,GAAG6C,EAAE,CAAC7C,QAAQ;MAAEG,IAAI,GAAG0C,EAAE,CAAC1C,IAAI;IACxE,OAAOvE,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;MAC/C,IAAI2H,kBAAkB;MACtB,OAAOzG,WAAW,CAAC,IAAI,EAAE,UAAUgG,EAAE,EAAE;QACnC,QAAQA,EAAE,CAAC7F,KAAK;UACZ,KAAK,CAAC;YACFsG,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;YAC1D,OAAO,CAAC,CAAC,CAAC,WAAWD,kBAAkB,CAACI,oBAAoB,CAAC;cACrD3D,QAAQ,EAAEA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,QAAQ;cACxEG,IAAI,EAAEA,IAAI;cACVuD,UAAU,EAAEjF;YAChB,CAAC,CAAC,CAAC;UACX,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,YAAYqE,EAAE,CAAC5F,IAAI,CAAC,CAAC,CAAC;QAC5C;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIwB,MAAM,CAAClD,SAAS,CAACoI,aAAa,GAAG,UAAUhB,EAAE,EAAE;IAC3C,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAEE,EAAE,GAAGD,EAAE,CAAC7C,QAAQ;MAAEA,QAAQ,GAAG8C,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IACtF,IAAIS,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACE,kCAAkC,CAAC;MAAEzD,QAAQ,EAAEA,QAAQ;MAAE0D,UAAU,EAAEjF;IAAK,CAAC,CAAC;EAC1G,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAM,CAAClD,SAAS,CAACqI,eAAe,GAAG,YAAY;IAC3C,IAAIN,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACM,eAAe,CAAC,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACInF,MAAM,CAAClD,SAAS,CAACsI,yBAAyB,GAAG,YAAY;IACrD,IAAIP,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACO,yBAAyB,CAAC,CAAC;EACzD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIpF,MAAM,CAAClD,SAAS,CAACuI,yBAAyB,GAAG,YAAY;IACrD,IAAIR,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACQ,yBAAyB,CAAC,CAAC;EACzD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIrF,MAAM,CAAClD,SAAS,CAACwI,mBAAmB,GAAG,YAAY;IAC/C,IAAIT,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACS,mBAAmB,CAAC,CAAC;EACnD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACItF,MAAM,CAAClD,SAAS,CAACyI,4BAA4B,GAAG,YAAY;IACxD,IAAIV,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D,OAAOD,kBAAkB,CAACU,4BAA4B,CAAC,CAAC;EAC5D,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIvF,MAAM,CAAClD,SAAS,CAAC0I,WAAW,GAAG,YAAY;IACvC,OAAO,IAAI,CAACC,YAAY,CAAC,CAAC;EAC9B,CAAC;EACD;AACJ;AACA;AACA;EACIzF,MAAM,CAAClD,SAAS,CAAC4I,gBAAgB,GAAG,YAAY;IAC5C,OAAO,IAAI,CAAC1C,KAAK,CAACnD,OAAO;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIG,MAAM,CAAClD,SAAS,CAAC2I,YAAY,GAAG,YAAY;IACxC,OAAO,IAAI,CAACxC,OAAO,CAAC0C,SAAS,KAAKpF,MAAM,CAACqF,aAAa,IAAI,IAAI,CAAC3C,OAAO,CAAC0C,SAAS,KAAK,IAAI;EAC7F,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI3F,MAAM,CAAClD,SAAS,CAAC+I,SAAS,GAAG,YAAY;IACrC,OAAO,IAAI,CAAC5C,OAAO,CAAC6C,KAAK;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI9F,MAAM,CAAClD,SAAS,CAACyG,OAAO,GAAG,UAAUW,EAAE,EAAE;IACrC,IAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAEE,EAAE,GAAGD,EAAE,CAAC/C,iBAAiB;MAAEA,iBAAiB,GAAGgD,EAAE,KAAK,KAAK,CAAC,GAAGtE,KAAK,GAAGsE,EAAE;MAAE2B,mBAAmB,GAAG5B,EAAE,CAAC9C,SAAS;MAAEiD,EAAE,GAAGH,EAAE,CAAC7C,QAAQ;MAAEA,QAAQ,GAAGgD,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;MAAE/C,gBAAgB,GAAG4C,EAAE,CAAC5C,gBAAgB;MAAEG,SAAS,GAAGyC,EAAE,CAACzC,SAAS;MAAEC,eAAe,GAAGwC,EAAE,CAACxC,eAAe;MAAEC,kBAAkB,GAAGuC,EAAE,CAACvC,kBAAkB;MAAEH,IAAI,GAAG0C,EAAE,CAAC1C,IAAI;IACzW,OAAO,IAAI,CAACuE,WAAW,CAAC;MACpB5E,iBAAiB,EAAEA,iBAAiB;MACpC2E,mBAAmB,EAAEA,mBAAmB;MACxCzE,QAAQ,EAAEA,QAAQ;MAClB2E,QAAQ,EAAE,KAAK;MACf1E,gBAAgB,EAAEA,gBAAgB;MAClC;MACAG,SAAS,EAAEwE,sBAAsB,CAACxE,SAAS,EAAE,IAAI,CAACuB,OAAO,CAACvB,SAAS,CAAC;MACpEC,eAAe,EAAEA,eAAe;MAChCC,kBAAkB,EAAEA,kBAAkB;MACtCH,IAAI,EAAEA;IACV,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIzB,MAAM,CAAClD,SAAS,CAACqJ,KAAK,GAAG,YAAY;IACjC,IAAI,CAACjD,IAAI,CAACkD,IAAI,CAAC,SAAS,CAAC1B,MAAM,CAAC,IAAI,CAAC3B,GAAG,EAAE,UAAU,CAAC,CAAC;IACtD,IAAI,IAAI,CAACU,mBAAmB,IAAI,IAAI,EAAE;MAClC,OAAO,IAAI,CAACA,mBAAmB,CAAC0C,KAAK,CAAC,CAAC;IAC3C;IACA,OAAOzI,OAAO,CAACD,OAAO,CAAC,CAAC;EAC5B,CAAC;EACD;EACA;EACAuC,MAAM,CAAClD,SAAS,CAACiC,MAAM,CAACsH,YAAY,CAAC,GAAG,YAAY;IAChD,OAAO,IAAI,CAACF,KAAK,CAAC,CAAC;EACvB,CAAC;EACD;AACJ;AACA;AACA;EACInG,MAAM,CAAClD,SAAS,CAAC6G,kBAAkB,GAAG,YAAY;IAC9C,IAAI,CAACT,IAAI,CAACkD,IAAI,CAAC,EAAE,CAAC1B,MAAM,CAAC,IAAI,CAAC1B,KAAK,CAACsD,QAAQ,EAAE,UAAU,CAAC,CAAC5B,MAAM,CAAC,IAAI,CAAC3B,GAAG,EAAE,8BAA8B,CAAC,CAAC2B,MAAM,CAAC,IAAI,CAAC1B,KAAK,CAACuD,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;EACrJ,CAAC;EACDxG,MAAM,CAAClD,SAAS,CAAC2J,qBAAqB,GAAG,UAAUC,QAAQ,EAAEpF,QAAQ,EAAE;IACnE,IAAI,CAACoC,iBAAiB,CAACiD,GAAG,CAACD,QAAQ,EAAEpF,QAAQ,CAAC;EAClD,CAAC;EACD;AACJ;AACA;EACItB,MAAM,CAAClD,SAAS,CAACkJ,WAAW,GAAG,UAAU9B,EAAE,EAAE;IACzC,IAAI9C,iBAAiB,GAAG8C,EAAE,CAAC9C,iBAAiB;MAAE2E,mBAAmB,GAAG7B,EAAE,CAAC6B,mBAAmB;MAAEzE,QAAQ,GAAG4C,EAAE,CAAC5C,QAAQ;MAAE2E,QAAQ,GAAG/B,EAAE,CAAC+B,QAAQ;MAAE1E,gBAAgB,GAAG2C,EAAE,CAAC3C,gBAAgB;MAAEG,SAAS,GAAGwC,EAAE,CAACxC,SAAS;MAAEC,eAAe,GAAGuC,EAAE,CAACvC,eAAe;MAAEC,kBAAkB,GAAGsC,EAAE,CAACtC,kBAAkB;MAAEH,IAAI,GAAGyC,EAAE,CAACzC,IAAI;IAC9S,IAAImF,WAAW,GAAGtG,SAAS,CAACmC,OAAO,CAACoE,oBAAoB,CAACzF,iBAAiB,CAAC;IAC3E,IAAIyD,kBAAkB,GAAG,IAAI,CAACC,8BAA8B,CAAC,CAAC;IAC9D;IACA,IAAIgC,kBAAkB,GAAG,IAAI,CAACpD,iBAAiB,CAACE,GAAG,CAAC,CAAC,CAAC,EAAE/C,WAAW,CAAC6F,QAAQ,EAAEjF,IAAI,EAAEF,gBAAgB,CAAC,CAAC;IACtG,IAAIwF,oBAAoB,GAAG,IAAI,CAACN,qBAAqB,CAACjD,IAAI,CAAC,IAAI,CAAC;IAChE,IAAInC,SAAS,GAAG0E,mBAAmB,IAAI,IAAI,GACrC,IAAI9F,WAAW,CAAC+G,SAAS,CAACjB,mBAAmB,CAAC,GAC9C9F,WAAW,CAAC+G,SAAS,CAACC,KAAK,CAAC,CAAC;IACnC,OAAO,IAAI,CAAC7D,cAAc,CAAC;MACvB8D,IAAI,EAAEN,WAAW;MACjBtF,QAAQ,EAAEA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,EAAE;MAClEuD,kBAAkB,EAAEA,kBAAkB;MACtCxD,SAAS,EAAEA,SAAS;MACpBe,MAAM,EAAEhG,QAAQ,CAAC;QAAE0K,kBAAkB,EAAEA,kBAAkB;QAAEK,aAAa,EAAE,IAAI,CAACzB,gBAAgB,CAAC;MAAE,CAAC,EAAE,IAAI,CAACzC,OAAO,CAAC;MAClHgD,QAAQ,EAAEA,QAAQ;MAClB1E,gBAAgB,EAAEA,gBAAgB;MAClCG,SAAS,EAAEA,SAAS;MACpBC,eAAe,EAAEA,eAAe;MAChCC,kBAAkB,EAAEA,kBAAkB;MACtCH,IAAI,EAAEA,IAAI;MACVkB,GAAG,EAAE,IAAI,CAACO,IAAI;MACd6D,oBAAoB,EAAEA;IAC1B,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;EACI/G,MAAM,CAAClD,SAAS,CAACgI,8BAA8B,GAAG,YAAY;IAC1D,IAAI,IAAI,CAACrB,mBAAmB,IAAI,IAAI,EAAE;MAClC,IAAI,CAACA,mBAAmB,GAAG,IAAI,CAACN,yBAAyB,CAAC,IAAI,CAACJ,GAAG,EAAE,IAAI,CAACE,OAAO,EAAE,IAAI,CAACC,IAAI,EAAEkE,sBAAsB,CAAC,IAAI,CAACnE,OAAO,CAAC,CAAC;IACtI;IACA,OAAO,IAAI,CAACQ,mBAAmB;EACnC,CAAC;EACD,OAAOzD,MAAM;AACjB,CAAC,CAAC,CAAE;AACJN,OAAO,CAACM,MAAM,GAAGA,MAAM;AACvB;AACA;AACA;AACA;AACA,SAAS8C,cAAcA,CAACV,MAAM,EAAEO,GAAG,EAAE;EACjC,IAAIuB,EAAE,EAAEC,EAAE;EACV,IAAIkD,QAAQ,GAAGjF,MAAM,CAACiF,QAAQ;EAC9B,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK7F,SAAS,IAAI,OAAO6F,QAAQ,KAAK,UAAU,EAAE;IAC/E,MAAM,IAAIlI,SAAS,CAAC,iDAAiD,CAACuF,MAAM,CAAC,OAAO2C,QAAQ,CAAC,CAAC;EAClG;EACA,IAAIjF,MAAM,CAACkF,4BAA4B,GAAGlF,MAAM,CAACmF,iBAAiB,EAAE;IAChE5E,GAAG,CAAC6E,IAAI,CAAC,0EAA0E,GAC/E,yEAAyE,GACzE,4EAA4E,GAC5E,wDAAwD,CAAC;EACjE;EACA,IAAI,CAAC,CAACtD,EAAE,GAAG9B,MAAM,CAACR,kBAAkB,MAAM,IAAI,IAAIsC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACuD,kBAAkB,KAAK,IAAI,IAAI,CAAC,CAACtD,EAAE,GAAG/B,MAAM,CAACR,kBAAkB,MAAM,IAAI,IAAIuC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACuD,uBAAuB,KAAK,IAAI,EAAE;IACrN,MAAM,IAAIC,KAAK,CAAC,0HAA0H,CAAC;EAC/I;EACA,OAAOvF,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,SAASM,cAAcA,CAACN,MAAM,EAAE;EAC5BA,MAAM,CAACwF,qBAAqB,GAAGC,gBAAgB,CAACzF,MAAM,CAACwF,qBAAqB,EAAE9G,+BAA+B,CAAC;EAC9GsB,MAAM,CAAC0F,qBAAqB,GAAGD,gBAAgB,CAACzF,MAAM,CAAC0F,qBAAqB,EAAE1H,WAAW,CAAC2H,qBAAqB,CAAC;EAChH3F,MAAM,CAACkF,4BAA4B,GAAGO,gBAAgB,CAACzF,MAAM,CAACkF,4BAA4B,EAAElH,WAAW,CAAC4H,gCAAgC,CAAC;EACzI5F,MAAM,CAACV,SAAS,GAAGwE,sBAAsB,CAAC9D,MAAM,CAACV,SAAS,EAAEX,kBAAkB,CAAC;EAC/EqB,MAAM,CAACmF,iBAAiB,GAAGU,wBAAwB,CAAC7F,MAAM,CAAC;EAC3DA,MAAM,CAAC8F,8BAA8B,GACjCC,+CAA+C,CAAC/F,MAAM,CAAC8F,8BAA8B,CAAC;AAC9F;AACA;AACA;AACA;AACA;AACA,SAASL,gBAAgBA,CAACO,QAAQ,EAAEC,iBAAiB,EAAE;EACnD,IAAIC,cAAc,GAAGC,QAAQ,CAACH,QAAQ,EAAE,EAAE,CAAC;EAC3C,IAAIE,cAAc,GAAG,CAAC,IAAIA,cAAc,KAAK,CAAC,EAAE;IAC5C,OAAOA,cAAc;EACzB,CAAC,MACI,IAAIA,cAAc,GAAG,CAAC,EAAE;IACzB,OAAOE,MAAM,CAACC,gBAAgB;EAClC,CAAC,MACI;IACD,OAAOJ,iBAAiB;EAC5B;AACJ;AACA;AACA;AACA;AACA,SAASnC,sBAAsBA,CAACkC,QAAQ,EAAEC,iBAAiB,EAAE;EACzD,IAAI3G,SAAS,GAAG6G,QAAQ,CAACH,QAAQ,EAAE,EAAE,CAAC;EACtC,IAAI1G,SAAS,GAAG,CAAC,IAAIA,SAAS,KAAKtB,WAAW,CAACsI,SAAS,EAAE;IACtD,OAAOhH,SAAS;EACpB,CAAC,MACI,IAAIA,SAAS,KAAK,CAAC,IAAIA,SAAS,GAAG,CAAC,EAAE;IACvC,MAAM,IAAIiG,KAAK,CAAC,iDAAiD,CAACjD,MAAM,CAACtE,WAAW,CAACsI,SAAS,EAAE,gCAAgC,CAAC,CAAChE,MAAM,CAAChD,SAAS,CAAC,CAAC;EACxJ,CAAC,MACI;IACD,OAAO2G,iBAAiB;EAC5B;AACJ;AACA;AACA;AACA;AACA,SAASJ,wBAAwBA,CAAC7F,MAAM,EAAE;EACtC,IAAIuG,iBAAiB,GAAGJ,QAAQ,CAACnG,MAAM,CAACmF,iBAAiB,EAAE,EAAE,CAAC;EAC9D,IAAIoB,iBAAiB,KAAK,CAAC,EAAE;IACzB;IACA,OAAO,IAAI;EACf,CAAC,MACI,IAAI,CAACC,KAAK,CAACD,iBAAiB,CAAC,IAAIA,iBAAiB,GAAG,CAAC,EAAE;IACzD;IACA,OAAO,IAAI;EACf,CAAC,MACI,IAAIC,KAAK,CAACD,iBAAiB,CAAC,EAAE;IAC/B;IACA,OAAOvI,WAAW,CAACyI,iCAAiC;EACxD,CAAC,MACI;IACD;IACA,OAAOF,iBAAiB;EAC5B;AACJ;AACA;AACA;AACA;AACA,SAASR,+CAA+CA,CAACC,QAAQ,EAAE;EAC/D,IAAIA,QAAQ,IAAI,IAAI,EAAE;IAClB,OAAO5G,SAAS;EACpB;EACA,IAAI0G,8BAA8B,GAAGK,QAAQ,CAACH,QAAQ,EAAE,EAAE,CAAC;EAC3D,IAAIF,8BAA8B,GAAG,CAAC,IAAIM,MAAM,CAACI,KAAK,CAACV,8BAA8B,CAAC,EAAE;IACpF,MAAM,IAAIP,KAAK,CAAC,4HAA4H,CAACjD,MAAM,CAACwD,8BAA8B,CAAC,CAAC;EACxL;EACA,OAAOA,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAASd,sBAAsBA,CAAChF,MAAM,EAAE;EACpC,OAAO,IAAIjC,4BAA4B,CAACsC,OAAO,CAACL,MAAM,CAACiF,QAAQ,CAAC;AACpE;AACA3H,OAAO,CAAC+C,OAAO,GAAGzC,MAAM","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}