{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\nvar json_1 = require(\"./json\");\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\nfunction hasIdentifierProperty(obj, property) {\n  return obj != null && obj[property] === true;\n}\n/**\n * Class for Node Type.\n */\nvar Node = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {Array<string>} labels - Array for all labels\n   * @param {Properties} properties - Map with node properties\n   * @param {string} elementId - Node element identifier\n   */\n  function Node(identity, labels, properties, elementId) {\n    /**\n     * Identity of the node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Node#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Labels of the node.\n     * @type {string[]}\n     */\n    this.labels = labels;\n    /**\n     * Properties of the node.\n     * @type {Properties}\n     */\n    this.properties = properties;\n    /**\n     * The Node element identifier.\n     * @type {string}\n     */\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n  }\n  /**\n   * @ignore\n   */\n  Node.prototype.toString = function () {\n    var s = '(' + this.elementId;\n    for (var i = 0; i < this.labels.length; i++) {\n      s += ':' + this.labels[i];\n    }\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ')';\n    return s;\n  };\n  return Node;\n}();\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\nvar Relationship = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {NumberOrInteger} start - Identity of start Node\n   * @param {NumberOrInteger} end - Identity of end Node\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   * @param {string} elementId - Relationship element identifier\n   * @param {string} startNodeElementId - Start Node element identifier\n   * @param {string} endNodeElementId - End Node element identifier\n   */\n  function Relationship(identity, start, end, type, properties, elementId, startNodeElementId, endNodeElementId) {\n    /**\n     * Identity of the relationship.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Identity of the start node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#startNodeElementId} instead\n     */\n    this.start = start;\n    /**\n     * Identity of the end node.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link Relationship#endNodeElementId} instead\n     */\n    this.end = end;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n    this.properties = properties;\n    /**\n     * The Relationship element identifier.\n     * @type {string}\n     */\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n    /**\n     * The Start Node element identifier.\n     * @type {string}\n     */\n    this.startNodeElementId = _valueOrGetDefault(startNodeElementId, function () {\n      return start.toString();\n    });\n    /**\n     * The End Node element identifier.\n     * @type {string}\n     */\n    this.endNodeElementId = _valueOrGetDefault(endNodeElementId, function () {\n      return end.toString();\n    });\n  }\n  /**\n   * @ignore\n   */\n  Relationship.prototype.toString = function () {\n    var s = '(' + this.startNodeElementId + ')-[:' + this.type;\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ']->(' + this.endNodeElementId + ')';\n    return s;\n  };\n  return Relationship;\n}();\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\nvar UnboundRelationship = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {NumberOrInteger} identity - Unique identity\n   * @param {string} type - Relationship type\n   * @param {Properties} properties - Map with relationship properties\n   * @param {string} elementId - Relationship element identifier\n   */\n  function UnboundRelationship(identity, type, properties, elementId) {\n    /**\n     * Identity of the relationship.\n     * @type {NumberOrInteger}\n     * @deprecated use {@link UnboundRelationship#elementId} instead\n     */\n    this.identity = identity;\n    /**\n     * Type of the relationship.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Properties of the relationship.\n     * @type {Properties}\n     */\n    this.properties = properties;\n    /**\n     * The Relationship element identifier.\n     * @type {string}\n     */\n    this.elementId = _valueOrGetDefault(elementId, function () {\n      return identity.toString();\n    });\n  }\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @deprecated use {@link UnboundRelationship#bindTo} instead\n   * @param {Integer} start - Identity of start node\n   * @param {Integer} end - Identity of end node\n   * @return {Relationship} - Created relationship\n   */\n  UnboundRelationship.prototype.bind = function (start, end) {\n    return new Relationship(this.identity, start, end, this.type, this.properties, this.elementId);\n  };\n  /**\n   * Bind relationship\n   *\n   * @protected\n   * @param {Node} start - Start Node\n   * @param {Node} end - End Node\n   * @return {Relationship} - Created relationship\n   */\n  UnboundRelationship.prototype.bindTo = function (start, end) {\n    return new Relationship(this.identity, start.identity, end.identity, this.type, this.properties, this.elementId, start.elementId, end.elementId);\n  };\n  /**\n   * @ignore\n   */\n  UnboundRelationship.prototype.toString = function () {\n    var s = '-[:' + this.type;\n    var keys = Object.keys(this.properties);\n    if (keys.length > 0) {\n      s += ' {';\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n      s += '}';\n    }\n    s += ']->';\n    return s;\n  };\n  return UnboundRelationship;\n}();\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n * @access private\n */\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\nvar PathSegment = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start - start node\n   * @param {Relationship} rel - relationship that connects start and end node\n   * @param {Node} end - end node\n   */\n  function PathSegment(start, rel, end) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * Relationship.\n     * @type {Relationship}\n     */\n    this.relationship = rel;\n    /**\n     * End node.\n     * @type {Node}\n     */\n    this.end = end;\n  }\n  return PathSegment;\n}();\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\nvar Path = /** @class */function () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Node} start  - start node\n   * @param {Node} end - end node\n   * @param {Array<PathSegment>} segments - Array of Segments\n   */\n  function Path(start, end, segments) {\n    /**\n     * Start node.\n     * @type {Node}\n     */\n    this.start = start;\n    /**\n     * End node.\n     * @type {Node}\n     */\n    this.end = end;\n    /**\n     * Segments.\n     * @type {Array<PathSegment>}\n     */\n    this.segments = segments;\n    /**\n     * Length of the segments.\n     * @type {Number}\n     */\n    this.length = segments.length;\n  }\n  return Path;\n}();\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\nexports.isPath = isPath;\nfunction _valueOrGetDefault(value, getDefault) {\n  return value === undefined || value === null ? getDefault() : value;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","isPathSegment","PathSegment","isPath","Path","isUnboundRelationship","UnboundRelationship","isRelationship","Relationship","isNode","Node","json_1","require","IDENTIFIER_PROPERTY_ATTRIBUTES","enumerable","configurable","writable","NODE_IDENTIFIER_PROPERTY","RELATIONSHIP_IDENTIFIER_PROPERTY","UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY","PATH_IDENTIFIER_PROPERTY","PATH_SEGMENT_IDENTIFIER_PROPERTY","hasIdentifierProperty","obj","property","identity","labels","properties","elementId","_valueOrGetDefault","toString","prototype","s","i","length","keys","stringify","start","end","type","startNodeElementId","endNodeElementId","bind","bindTo","rel","relationship","segments","getDefault","undefined"],"sources":["D:/Study/Projects/El-Kasr Family Tree/client/node_modules/neo4j-driver-core/lib/graph-types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\nvar json_1 = require(\"./json\");\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n    value: true,\n    enumerable: false,\n    configurable: false,\n    writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\nfunction hasIdentifierProperty(obj, property) {\n    return obj != null && obj[property] === true;\n}\n/**\n * Class for Node Type.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {Array<string>} labels - Array for all labels\n     * @param {Properties} properties - Map with node properties\n     * @param {string} elementId - Node element identifier\n     */\n    function Node(identity, labels, properties, elementId) {\n        /**\n         * Identity of the node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Node#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Labels of the node.\n         * @type {string[]}\n         */\n        this.labels = labels;\n        /**\n         * Properties of the node.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Node element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Node.prototype.toString = function () {\n        var s = '(' + this.elementId;\n        for (var i = 0; i < this.labels.length; i++) {\n            s += ':' + this.labels[i];\n        }\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ')';\n        return s;\n    };\n    return Node;\n}());\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\nfunction isNode(obj) {\n    return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\nvar Relationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {NumberOrInteger} start - Identity of start Node\n     * @param {NumberOrInteger} end - Identity of end Node\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     * @param {string} startNodeElementId - Start Node element identifier\n     * @param {string} endNodeElementId - End Node element identifier\n     */\n    function Relationship(identity, start, end, type, properties, elementId, startNodeElementId, endNodeElementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Identity of the start node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#startNodeElementId} instead\n         */\n        this.start = start;\n        /**\n         * Identity of the end node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#endNodeElementId} instead\n         */\n        this.end = end;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n        /**\n         * The Start Node element identifier.\n         * @type {string}\n         */\n        this.startNodeElementId = _valueOrGetDefault(startNodeElementId, function () { return start.toString(); });\n        /**\n         * The End Node element identifier.\n         * @type {string}\n         */\n        this.endNodeElementId = _valueOrGetDefault(endNodeElementId, function () { return end.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Relationship.prototype.toString = function () {\n        var s = '(' + this.startNodeElementId + ')-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->(' + this.endNodeElementId + ')';\n        return s;\n    };\n    return Relationship;\n}());\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\nfunction isRelationship(obj) {\n    return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\nvar UnboundRelationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     */\n    function UnboundRelationship(identity, type, properties, elementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link UnboundRelationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @deprecated use {@link UnboundRelationship#bindTo} instead\n     * @param {Integer} start - Identity of start node\n     * @param {Integer} end - Identity of end node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bind = function (start, end) {\n        return new Relationship(this.identity, start, end, this.type, this.properties, this.elementId);\n    };\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @param {Node} start - Start Node\n     * @param {Node} end - End Node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bindTo = function (start, end) {\n        return new Relationship(this.identity, start.identity, end.identity, this.type, this.properties, this.elementId, start.elementId, end.elementId);\n    };\n    /**\n     * @ignore\n     */\n    UnboundRelationship.prototype.toString = function () {\n        var s = '-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->';\n        return s;\n    };\n    return UnboundRelationship;\n}());\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n * @access private\n */\nfunction isUnboundRelationship(obj) {\n    return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\nvar PathSegment = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start - start node\n     * @param {Relationship} rel - relationship that connects start and end node\n     * @param {Node} end - end node\n     */\n    function PathSegment(start, rel, end) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * Relationship.\n         * @type {Relationship}\n         */\n        this.relationship = rel;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n    }\n    return PathSegment;\n}());\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\nfunction isPathSegment(obj) {\n    return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\nvar Path = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start  - start node\n     * @param {Node} end - end node\n     * @param {Array<PathSegment>} segments - Array of Segments\n     */\n    function Path(start, end, segments) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n        /**\n         * Segments.\n         * @type {Array<PathSegment>}\n         */\n        this.segments = segments;\n        /**\n         * Length of the segments.\n         * @type {Number}\n         */\n        this.length = segments.length;\n    }\n    return Path;\n}());\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\nfunction isPath(obj) {\n    return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\nexports.isPath = isPath;\nfunction _valueOrGetDefault(value, getDefault) {\n    return value === undefined || value === null ? getDefault() : value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}