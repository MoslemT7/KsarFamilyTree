{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeTransformer = void 0;\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar objectUtil = neo4j_driver_core_1.internal.objectUtil;\n/**\n * Class responsible for applying the expected {@link TypeTransformer} to\n * transform the driver types from and to {@link struct.Structure}\n */\nvar Transformer = /** @class */function () {\n  /**\n   * Constructor\n   * @param {TypeTransformer[]} transformers The type transformers\n   */\n  function Transformer(transformers) {\n    this._transformers = transformers;\n    this._transformersPerSignature = new Map(transformers.map(function (typeTransformer) {\n      return [typeTransformer.signature, typeTransformer];\n    }));\n    this.fromStructure = this.fromStructure.bind(this);\n    this.toStructure = this.toStructure.bind(this);\n    Object.freeze(this);\n  }\n  /**\n   * Transform from structure to specific object\n   *\n   * @param {struct.Structure} struct The structure\n   * @returns {<T>|structure.Structure} The driver object or the structure if the transformer was not found.\n   */\n  Transformer.prototype.fromStructure = function (struct) {\n    try {\n      if (struct instanceof packstream_1.structure.Structure && this._transformersPerSignature.has(struct.signature)) {\n        var fromStructure = this._transformersPerSignature.get(struct.signature).fromStructure;\n        return fromStructure(struct);\n      }\n      return struct;\n    } catch (error) {\n      return objectUtil.createBrokenObject(error);\n    }\n  };\n  /**\n   * Transform from object to structure\n   * @param {<T>} type The object to be transoformed in structure\n   * @returns {<T>|structure.Structure} The structure or the object, if any transformer was found\n   */\n  Transformer.prototype.toStructure = function (type) {\n    var transformer = this._transformers.find(function (_a) {\n      var isTypeInstance = _a.isTypeInstance;\n      return isTypeInstance(type);\n    });\n    if (transformer !== undefined) {\n      return transformer.toStructure(type);\n    }\n    return type;\n  };\n  return Transformer;\n}();\nexports.default = Transformer;\n/**\n * @callback isTypeInstanceFunction\n * @param {any} object The object\n * @return {boolean} is instance of\n */\n/**\n * @callback toStructureFunction\n * @param {any} object The object\n * @return {structure.Structure} The structure\n */\n/**\n * @callback fromStructureFunction\n * @param {structure.Structure} struct The structure\n * @return {any} The object\n */\n/**\n * Class responsible for grouping the properties of a TypeTransformer\n */\nvar TypeTransformer = /** @class */function () {\n  /**\n   * @param {Object} param\n   * @param {number} param.signature The signature of the structure\n   * @param {isTypeInstanceFunction} param.isTypeInstance The function which checks if object is\n   *                instance of the type described by the TypeTransformer\n   * @param {toStructureFunction} param.toStructure The function which gets the object and converts to structure\n   * @param {fromStructureFunction} param.fromStructure The function which get the structure and covnverts to object\n   */\n  function TypeTransformer(_a) {\n    var signature = _a.signature,\n      fromStructure = _a.fromStructure,\n      toStructure = _a.toStructure,\n      isTypeInstance = _a.isTypeInstance;\n    this.signature = signature;\n    this.isTypeInstance = isTypeInstance;\n    this.fromStructure = fromStructure;\n    this.toStructure = toStructure;\n    Object.freeze(this);\n  }\n  /**\n   * @param {Object} param\n   * @param {number} [param.signature] The signature of the structure\n   * @param {isTypeInstanceFunction} [param.isTypeInstance] The function which checks if object is\n   *                instance of the type described by the TypeTransformer\n   * @param {toStructureFunction} [param.toStructure] The function which gets the object and converts to structure\n   * @param {fromStructureFunction} pparam.fromStructure] The function which get the structure and covnverts to object\n   * @returns {TypeTransformer} A new type transform extends with new methods\n   */\n  TypeTransformer.prototype.extendsWith = function (_a) {\n    var signature = _a.signature,\n      fromStructure = _a.fromStructure,\n      toStructure = _a.toStructure,\n      isTypeInstance = _a.isTypeInstance;\n    return new TypeTransformer({\n      signature: signature || this.signature,\n      fromStructure: fromStructure || this.fromStructure,\n      toStructure: toStructure || this.toStructure,\n      isTypeInstance: isTypeInstance || this.isTypeInstance\n    });\n  };\n  return TypeTransformer;\n}();\nexports.TypeTransformer = TypeTransformer;","map":{"version":3,"names":["Object","defineProperty","exports","value","TypeTransformer","packstream_1","require","neo4j_driver_core_1","objectUtil","internal","Transformer","transformers","_transformers","_transformersPerSignature","Map","map","typeTransformer","signature","fromStructure","bind","toStructure","freeze","prototype","struct","structure","Structure","has","get","error","createBrokenObject","type","transformer","find","_a","isTypeInstance","undefined","default","extendsWith"],"sources":["D:/Study/Projects/Copy 4/client/node_modules/neo4j-driver-bolt-connection/lib/bolt/transformer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeTransformer = void 0;\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar objectUtil = neo4j_driver_core_1.internal.objectUtil;\n/**\n * Class responsible for applying the expected {@link TypeTransformer} to\n * transform the driver types from and to {@link struct.Structure}\n */\nvar Transformer = /** @class */ (function () {\n    /**\n     * Constructor\n     * @param {TypeTransformer[]} transformers The type transformers\n     */\n    function Transformer(transformers) {\n        this._transformers = transformers;\n        this._transformersPerSignature = new Map(transformers.map(function (typeTransformer) { return [typeTransformer.signature, typeTransformer]; }));\n        this.fromStructure = this.fromStructure.bind(this);\n        this.toStructure = this.toStructure.bind(this);\n        Object.freeze(this);\n    }\n    /**\n     * Transform from structure to specific object\n     *\n     * @param {struct.Structure} struct The structure\n     * @returns {<T>|structure.Structure} The driver object or the structure if the transformer was not found.\n     */\n    Transformer.prototype.fromStructure = function (struct) {\n        try {\n            if (struct instanceof packstream_1.structure.Structure && this._transformersPerSignature.has(struct.signature)) {\n                var fromStructure = this._transformersPerSignature.get(struct.signature).fromStructure;\n                return fromStructure(struct);\n            }\n            return struct;\n        }\n        catch (error) {\n            return objectUtil.createBrokenObject(error);\n        }\n    };\n    /**\n     * Transform from object to structure\n     * @param {<T>} type The object to be transoformed in structure\n     * @returns {<T>|structure.Structure} The structure or the object, if any transformer was found\n     */\n    Transformer.prototype.toStructure = function (type) {\n        var transformer = this._transformers.find(function (_a) {\n            var isTypeInstance = _a.isTypeInstance;\n            return isTypeInstance(type);\n        });\n        if (transformer !== undefined) {\n            return transformer.toStructure(type);\n        }\n        return type;\n    };\n    return Transformer;\n}());\nexports.default = Transformer;\n/**\n * @callback isTypeInstanceFunction\n * @param {any} object The object\n * @return {boolean} is instance of\n */\n/**\n * @callback toStructureFunction\n * @param {any} object The object\n * @return {structure.Structure} The structure\n */\n/**\n * @callback fromStructureFunction\n * @param {structure.Structure} struct The structure\n * @return {any} The object\n */\n/**\n * Class responsible for grouping the properties of a TypeTransformer\n */\nvar TypeTransformer = /** @class */ (function () {\n    /**\n     * @param {Object} param\n     * @param {number} param.signature The signature of the structure\n     * @param {isTypeInstanceFunction} param.isTypeInstance The function which checks if object is\n     *                instance of the type described by the TypeTransformer\n     * @param {toStructureFunction} param.toStructure The function which gets the object and converts to structure\n     * @param {fromStructureFunction} param.fromStructure The function which get the structure and covnverts to object\n     */\n    function TypeTransformer(_a) {\n        var signature = _a.signature, fromStructure = _a.fromStructure, toStructure = _a.toStructure, isTypeInstance = _a.isTypeInstance;\n        this.signature = signature;\n        this.isTypeInstance = isTypeInstance;\n        this.fromStructure = fromStructure;\n        this.toStructure = toStructure;\n        Object.freeze(this);\n    }\n    /**\n     * @param {Object} param\n     * @param {number} [param.signature] The signature of the structure\n     * @param {isTypeInstanceFunction} [param.isTypeInstance] The function which checks if object is\n     *                instance of the type described by the TypeTransformer\n     * @param {toStructureFunction} [param.toStructure] The function which gets the object and converts to structure\n     * @param {fromStructureFunction} pparam.fromStructure] The function which get the structure and covnverts to object\n     * @returns {TypeTransformer} A new type transform extends with new methods\n     */\n    TypeTransformer.prototype.extendsWith = function (_a) {\n        var signature = _a.signature, fromStructure = _a.fromStructure, toStructure = _a.toStructure, isTypeInstance = _a.isTypeInstance;\n        return new TypeTransformer({\n            signature: signature || this.signature,\n            fromStructure: fromStructure || this.fromStructure,\n            toStructure: toStructure || this.toStructure,\n            isTypeInstance: isTypeInstance || this.isTypeInstance\n        });\n    };\n    return TypeTransformer;\n}());\nexports.TypeTransformer = TypeTransformer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}