{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar bolt_protocol_v4x4_transformer_1 = __importDefault(require(\"./bolt-protocol-v4x4.transformer\"));\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar functional_1 = require(\"../lang/functional\");\nvar localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x49;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x69;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nfunction createDateTimeWithZoneIdTransformer(config, logger) {\n  var disableLosslessIntegers = config.disableLosslessIntegers,\n    useBigInt = config.useBigInt;\n  var dateTimeWithZoneIdTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithZoneIdTransformer(config);\n  return dateTimeWithZoneIdTransformer.extendsWith({\n    signature: DATE_TIME_WITH_ZONE_ID,\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, struct.size);\n      var _a = __read(struct.fields, 3),\n        epochSecond = _a[0],\n        nano = _a[1],\n        timeZoneId = _a[2];\n      var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);\n      var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);\n      return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n    },\n    toStructure: function (value) {\n      var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n      var offset = value.timeZoneOffsetSeconds != null ? value.timeZoneOffsetSeconds : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);\n      if (value.timeZoneOffsetSeconds == null) {\n        logger.warn('DateTime objects without \"timeZoneOffsetSeconds\" property ' + 'are prune to bugs related to ambiguous times. For instance, ' + '2022-10-30T2:30:00[Europe/Berlin] could be GMT+1 or GMT+2.');\n      }\n      var utc = epochSecond.subtract(offset);\n      var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n      var timeZoneId = value.timeZoneId;\n      return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_ID, [utc, nano, timeZoneId]);\n    }\n  });\n}\n/**\n * Returns the offset for a given timezone id\n *\n * Javascript doesn't have support for direct getting the timezone offset from a given\n * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,\n *\n * 1. The ZoneId is applied to the timestamp, so we could make the difference between the\n * given timestamp and the new calculated one. This is the offset for the timezone\n * in the utc is equal to epoch (some time in the future or past)\n * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.\n * 3. The ZoneId is applied to the new timestamp, se we could could make the difference\n * between the new timestamp and the calculated one. This is the offset for the given timezone.\n *\n * Example:\n *    Input: 2022-3-27 1:59:59 'Europe/Berlin'\n *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00\n *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59\n *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00\n *  The offset is +1 hour.\n *\n * @param {string} timeZoneId The timezone id\n * @param {Integer} epochSecond The epoch second in the timezone id\n * @param {Integerable} nanosecond The nanoseconds in the timezone id\n * @returns The timezone offset\n */\nfunction getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {\n  var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond);\n  // The wallclock form the current date time\n  var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);\n  var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);\n  var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);\n  var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);\n  var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);\n  var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);\n  return offset;\n}\nvar dateTimeFormatCache = new Map();\nfunction getDateTimeFormatForZoneId(timeZoneId) {\n  if (!dateTimeFormatCache.has(timeZoneId)) {\n    var formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone: timeZoneId,\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      hour12: false,\n      era: 'narrow'\n    });\n    dateTimeFormatCache.set(timeZoneId, formatter);\n  }\n  return dateTimeFormatCache.get(timeZoneId);\n}\nfunction getTimeInZoneId(timeZoneId, epochSecond, nano) {\n  var formatter = getDateTimeFormatForZoneId(timeZoneId);\n  var utc = (0, neo4j_driver_core_1.int)(epochSecond).multiply(1000).add((0, neo4j_driver_core_1.int)(nano).div(1000000)).toNumber();\n  var formattedUtcParts = formatter.formatToParts(utc);\n  var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {\n    if (currentValue.type === 'era') {\n      obj.adjustEra = currentValue.value.toUpperCase() === 'B' ? function (year) {\n        return year.subtract(1).negate();\n      } // 1BC equals to year 0 in astronomical year numbering\n      : functional_1.identity;\n    } else if (currentValue.type === 'hour') {\n      obj.hour = (0, neo4j_driver_core_1.int)(currentValue.value).modulo(24);\n    } else if (currentValue.type !== 'literal') {\n      obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);\n    }\n    return obj;\n  }, {});\n  localDateTime.year = localDateTime.adjustEra(localDateTime.year);\n  var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);\n  localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);\n  localDateTime.hour = localDateTime.hour.modulo(24);\n  return localDateTime;\n}\nfunction createDateTimeWithOffsetTransformer(config) {\n  var disableLosslessIntegers = config.disableLosslessIntegers,\n    useBigInt = config.useBigInt;\n  var dateTimeWithOffsetTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithOffsetTransformer(config);\n  return dateTimeWithOffsetTransformer.extendsWith({\n    signature: DATE_TIME_WITH_ZONE_OFFSET,\n    toStructure: function (value) {\n      var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n      var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n      var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n      var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);\n      return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_OFFSET, [utcSecond, nano, timeZoneOffsetSeconds]);\n    },\n    fromStructure: function (struct) {\n      packstream_1.structure.verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, struct.size);\n      var _a = __read(struct.fields, 3),\n        utcSecond = _a[0],\n        nano = _a[1],\n        timeZoneOffsetSeconds = _a[2];\n      var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);\n      var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n      var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n      return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n    }\n  });\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n  var convert = function (value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n  var clone = Object.create(Object.getPrototypeOf(obj));\n  for (var prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n  Object.freeze(clone);\n  return clone;\n}\nexports.default = {\n  createDateTimeWithZoneIdTransformer: createDateTimeWithZoneIdTransformer,\n  createDateTimeWithOffsetTransformer: createDateTimeWithOffsetTransformer\n};","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__importDefault","mod","__esModule","Object","defineProperty","exports","packstream_1","require","neo4j_driver_core_1","bolt_protocol_v4x4_transformer_1","temporal_factory_1","functional_1","localDateTimeToEpochSecond","internal","temporalUtil","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","createDateTimeWithZoneIdTransformer","config","logger","disableLosslessIntegers","useBigInt","dateTimeWithZoneIdTransformer","default","extendsWith","signature","fromStructure","struct","structure","verifyStructSize","size","_a","fields","epochSecond","nano","timeZoneId","localDateTime","getTimeInZoneId","result","DateTime","year","month","day","hour","minute","second","int","timeZoneOffsetSeconds","convertIntegerPropsIfNeeded","toStructure","nanosecond","offset","getOffsetFromZoneId","warn","utc","subtract","Structure","dateTimeWithZoneAppliedTwice","epochWithZoneAppliedTwice","offsetOfZoneInTheFutureUtc","guessedUtc","zonedDateTimeFromGuessedUtc","zonedEpochFromGuessedUtc","dateTimeFormatCache","Map","getDateTimeFormatForZoneId","has","formatter","Intl","DateTimeFormat","timeZone","hour12","era","set","get","multiply","add","div","toNumber","formattedUtcParts","formatToParts","reduce","obj","currentValue","type","adjustEra","toUpperCase","negate","identity","modulo","epochInTimeZone","createDateTimeWithOffsetTransformer","dateTimeWithOffsetTransformer","utcSecond","epochSecondAndNanoToLocalDateTime","convert","toBigInt","toNumberOrInfinity","clone","create","getPrototypeOf","prop","prototype","hasOwnProperty","isInt","freeze"],"sources":["D:/Study/Projects/El-Kasr Family Tree/client/node_modules/neo4j-driver-bolt-connection/lib/bolt/bolt-protocol-v5x0.utc.transformer.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar packstream_1 = require(\"../packstream\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar bolt_protocol_v4x4_transformer_1 = __importDefault(require(\"./bolt-protocol-v4x4.transformer\"));\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar functional_1 = require(\"../lang/functional\");\nvar localDateTimeToEpochSecond = neo4j_driver_core_1.internal.temporalUtil.localDateTimeToEpochSecond;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x49;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x69;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nfunction createDateTimeWithZoneIdTransformer(config, logger) {\n    var disableLosslessIntegers = config.disableLosslessIntegers, useBigInt = config.useBigInt;\n    var dateTimeWithZoneIdTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithZoneIdTransformer(config);\n    return dateTimeWithZoneIdTransformer.extendsWith({\n        signature: DATE_TIME_WITH_ZONE_ID,\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), epochSecond = _a[0], nano = _a[1], timeZoneId = _a[2];\n            var localDateTime = getTimeInZoneId(timeZoneId, epochSecond, nano);\n            var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, (0, neo4j_driver_core_1.int)(nano), localDateTime.timeZoneOffsetSeconds, timeZoneId);\n            return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n        },\n        toStructure: function (value) {\n            var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n            var offset = value.timeZoneOffsetSeconds != null\n                ? value.timeZoneOffsetSeconds\n                : getOffsetFromZoneId(value.timeZoneId, epochSecond, value.nanosecond);\n            if (value.timeZoneOffsetSeconds == null) {\n                logger.warn('DateTime objects without \"timeZoneOffsetSeconds\" property ' +\n                    'are prune to bugs related to ambiguous times. For instance, ' +\n                    '2022-10-30T2:30:00[Europe/Berlin] could be GMT+1 or GMT+2.');\n            }\n            var utc = epochSecond.subtract(offset);\n            var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n            var timeZoneId = value.timeZoneId;\n            return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_ID, [utc, nano, timeZoneId]);\n        }\n    });\n}\n/**\n * Returns the offset for a given timezone id\n *\n * Javascript doesn't have support for direct getting the timezone offset from a given\n * TimeZoneId and DateTime in the given TimeZoneId. For solving this issue,\n *\n * 1. The ZoneId is applied to the timestamp, so we could make the difference between the\n * given timestamp and the new calculated one. This is the offset for the timezone\n * in the utc is equal to epoch (some time in the future or past)\n * 2. The offset is subtracted from the timestamp, so we have an estimated utc timestamp.\n * 3. The ZoneId is applied to the new timestamp, se we could could make the difference\n * between the new timestamp and the calculated one. This is the offset for the given timezone.\n *\n * Example:\n *    Input: 2022-3-27 1:59:59 'Europe/Berlin'\n *    Apply 1, 2022-3-27 1:59:59 => 2022-3-27 3:59:59 'Europe/Berlin' +2:00\n *    Apply 2, 2022-3-27 1:59:59 - 2:00 => 2022-3-26 23:59:59\n *    Apply 3, 2022-3-26 23:59:59 => 2022-3-27 00:59:59 'Europe/Berlin' +1:00\n *  The offset is +1 hour.\n *\n * @param {string} timeZoneId The timezone id\n * @param {Integer} epochSecond The epoch second in the timezone id\n * @param {Integerable} nanosecond The nanoseconds in the timezone id\n * @returns The timezone offset\n */\nfunction getOffsetFromZoneId(timeZoneId, epochSecond, nanosecond) {\n    var dateTimeWithZoneAppliedTwice = getTimeInZoneId(timeZoneId, epochSecond, nanosecond);\n    // The wallclock form the current date time\n    var epochWithZoneAppliedTwice = localDateTimeToEpochSecond(dateTimeWithZoneAppliedTwice.year, dateTimeWithZoneAppliedTwice.month, dateTimeWithZoneAppliedTwice.day, dateTimeWithZoneAppliedTwice.hour, dateTimeWithZoneAppliedTwice.minute, dateTimeWithZoneAppliedTwice.second, nanosecond);\n    var offsetOfZoneInTheFutureUtc = epochWithZoneAppliedTwice.subtract(epochSecond);\n    var guessedUtc = epochSecond.subtract(offsetOfZoneInTheFutureUtc);\n    var zonedDateTimeFromGuessedUtc = getTimeInZoneId(timeZoneId, guessedUtc, nanosecond);\n    var zonedEpochFromGuessedUtc = localDateTimeToEpochSecond(zonedDateTimeFromGuessedUtc.year, zonedDateTimeFromGuessedUtc.month, zonedDateTimeFromGuessedUtc.day, zonedDateTimeFromGuessedUtc.hour, zonedDateTimeFromGuessedUtc.minute, zonedDateTimeFromGuessedUtc.second, nanosecond);\n    var offset = zonedEpochFromGuessedUtc.subtract(guessedUtc);\n    return offset;\n}\nvar dateTimeFormatCache = new Map();\nfunction getDateTimeFormatForZoneId(timeZoneId) {\n    if (!dateTimeFormatCache.has(timeZoneId)) {\n        var formatter = new Intl.DateTimeFormat('en-US', {\n            timeZone: timeZoneId,\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric',\n            hour12: false,\n            era: 'narrow'\n        });\n        dateTimeFormatCache.set(timeZoneId, formatter);\n    }\n    return dateTimeFormatCache.get(timeZoneId);\n}\nfunction getTimeInZoneId(timeZoneId, epochSecond, nano) {\n    var formatter = getDateTimeFormatForZoneId(timeZoneId);\n    var utc = (0, neo4j_driver_core_1.int)(epochSecond)\n        .multiply(1000)\n        .add((0, neo4j_driver_core_1.int)(nano).div(1000000))\n        .toNumber();\n    var formattedUtcParts = formatter.formatToParts(utc);\n    var localDateTime = formattedUtcParts.reduce(function (obj, currentValue) {\n        if (currentValue.type === 'era') {\n            obj.adjustEra =\n                currentValue.value.toUpperCase() === 'B'\n                    ? function (year) { return year.subtract(1).negate(); } // 1BC equals to year 0 in astronomical year numbering\n                    : functional_1.identity;\n        }\n        else if (currentValue.type === 'hour') {\n            obj.hour = (0, neo4j_driver_core_1.int)(currentValue.value).modulo(24);\n        }\n        else if (currentValue.type !== 'literal') {\n            obj[currentValue.type] = (0, neo4j_driver_core_1.int)(currentValue.value);\n        }\n        return obj;\n    }, {});\n    localDateTime.year = localDateTime.adjustEra(localDateTime.year);\n    var epochInTimeZone = localDateTimeToEpochSecond(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond);\n    localDateTime.timeZoneOffsetSeconds = epochInTimeZone.subtract(epochSecond);\n    localDateTime.hour = localDateTime.hour.modulo(24);\n    return localDateTime;\n}\nfunction createDateTimeWithOffsetTransformer(config) {\n    var disableLosslessIntegers = config.disableLosslessIntegers, useBigInt = config.useBigInt;\n    var dateTimeWithOffsetTransformer = bolt_protocol_v4x4_transformer_1.default.createDateTimeWithOffsetTransformer(config);\n    return dateTimeWithOffsetTransformer.extendsWith({\n        signature: DATE_TIME_WITH_ZONE_OFFSET,\n        toStructure: function (value) {\n            var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n            var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n            var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n            var utcSecond = epochSecond.subtract(timeZoneOffsetSeconds);\n            return new packstream_1.structure.Structure(DATE_TIME_WITH_ZONE_OFFSET, [utcSecond, nano, timeZoneOffsetSeconds]);\n        },\n        fromStructure: function (struct) {\n            packstream_1.structure.verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, struct.size);\n            var _a = __read(struct.fields, 3), utcSecond = _a[0], nano = _a[1], timeZoneOffsetSeconds = _a[2];\n            var epochSecond = (0, neo4j_driver_core_1.int)(utcSecond).add(timeZoneOffsetSeconds);\n            var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n            var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n            return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n        }\n    });\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n    if (!disableLosslessIntegers && !useBigInt) {\n        return obj;\n    }\n    var convert = function (value) {\n        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n    };\n    var clone = Object.create(Object.getPrototypeOf(obj));\n    for (var prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop) === true) {\n            var value = obj[prop];\n            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n        }\n    }\n    Object.freeze(clone);\n    return clone;\n}\nexports.default = {\n    createDateTimeWithZoneIdTransformer: createDateTimeWithZoneIdTransformer,\n    createDateTimeWithOffsetTransformer: createDateTimeWithOffsetTransformer\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}